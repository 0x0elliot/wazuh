/*
 * Wazuh Vulnerability Scanner - Unit Tests
 * Copyright (C) 2015, Wazuh Inc.
 * September 21, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "factoryOrchestrator_test.hpp"
#include "MockDatabaseFeedManager.hpp"
#include "MockIndexerConnector.hpp"

/**
 * @brief PackageScanner fake class
 */
template<typename TDatabaseFeedManager = MockDatabaseFeedManager>
class TFakePackageScanner : public AbstractHandler<std::shared_ptr<std::vector<std::string>>>
{
public:
    /**
     * @brief Construct a new TFakePackageScanner object.
     *
     * @param databaseFeedManager TDatabaseFeedManager instance.
     */
    TFakePackageScanner(std::shared_ptr<TDatabaseFeedManager>& databaseFeedManager) {};
    virtual ~TFakePackageScanner() = default;

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Mocked context data
     * @return std::shared_ptr<std::vector<std::string>>
     */
    std::shared_ptr<std::vector<std::string>> handleRequest(std::shared_ptr<std::vector<std::string>> data) override
    {
        data->push_back("packageScanner");
        return AbstractHandler<std::shared_ptr<std::vector<std::string>>>::handleRequest(std::move(data));
    }
};
using FakePackageScanner = TFakePackageScanner<>;

/**
 * @brief EventPackageAlertDetailsBuilder fake class
 */
template<typename TDatabaseFeedManager = MockDatabaseFeedManager>
class TFakeEventPackageAlertDetailsBuilder : public AbstractHandler<std::shared_ptr<std::vector<std::string>>>
{
public:
    /**
     * @brief Construct a new TFakeEventPackageAlertDetailsBuilder object.
     *
     * @param databaseFeedManager TDatabaseFeedManager instance.
     */
    TFakeEventPackageAlertDetailsBuilder(std::shared_ptr<TDatabaseFeedManager>& databaseFeedManager) {};
    virtual ~TFakeEventPackageAlertDetailsBuilder() = default;

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Mocked context data
     * @return std::shared_ptr<std::vector<std::string>>
     */
    std::shared_ptr<std::vector<std::string>> handleRequest(std::shared_ptr<std::vector<std::string>> data) override
    {
        data->push_back("eventPackageAlertDetailsBuilder");
        return AbstractHandler<std::shared_ptr<std::vector<std::string>>>::handleRequest(std::move(data));
    }
};
using FakeEventPackageAlertDetailsBuilder = TFakeEventPackageAlertDetailsBuilder<>;

/**
 * @brief ScanOsAlertDetailsBuilder fake class.
 */
template<typename TDatabaseFeedManager = MockDatabaseFeedManager>
class TFakeScanOsAlertDetailsBuilder : public AbstractHandler<std::shared_ptr<std::vector<std::string>>>
{
public:
    /**
     * @brief Construct a new TFakeScanOsAlertDetailsBuilder object.
     *
     * @param databaseFeedManager TDatabaseFeedManager instance.
     */
    TFakeScanOsAlertDetailsBuilder(std::shared_ptr<TDatabaseFeedManager>& databaseFeedManager) {};
    virtual ~TFakeScanOsAlertDetailsBuilder() = default;

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Mocked context data
     * @return std::shared_ptr<std::vector<std::string>>
     */
    std::shared_ptr<std::vector<std::string>> handleRequest(std::shared_ptr<std::vector<std::string>> data) override
    {
        data->push_back("scanOsAlertDetailsBuilder");
        return AbstractHandler<std::shared_ptr<std::vector<std::string>>>::handleRequest(std::move(data));
    }
};
using FakeScanOsAlertDetailsBuilder = TFakeScanOsAlertDetailsBuilder<>;

/**
 * @brief EventDetailsBuilder fake class
 */
template<typename TDatabaseFeedManager = MockDatabaseFeedManager>
class TFakeEventDetailsBuilder : public AbstractHandler<std::shared_ptr<std::vector<std::string>>>
{
public:
    /**
     * @brief Construct a new TFakeEventDetailsBuilder object.
     *
     * @param databaseFeedManager TDatabaseFeedManager instance.
     */
    TFakeEventDetailsBuilder(std::shared_ptr<TDatabaseFeedManager>& databaseFeedManager) {};
    virtual ~TFakeEventDetailsBuilder() = default;

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Mocked context data
     * @return std::shared_ptr<std::vector<std::string>>
     */
    std::shared_ptr<std::vector<std::string>> handleRequest(std::shared_ptr<std::vector<std::string>> data) override
    {
        data->push_back("eventDetailsBuilder");
        return AbstractHandler<std::shared_ptr<std::vector<std::string>>>::handleRequest(std::move(data));
    }
};
using FakeEventDetailsBuilder = TFakeEventDetailsBuilder<>;

/**
 * @brief AlertClearBuilder fake class.
 */
template<typename TDatabaseFeedManager = MockDatabaseFeedManager>
class TFakeAlertClearBuilder : public AbstractHandler<std::shared_ptr<std::vector<std::string>>>
{
public:
    /**
     * @brief Construct a new TFakeAlertClearBuilder object.
     *
     * @param databaseFeedManager TDatabaseFeedManager instance.
     */
    TFakeAlertClearBuilder(std::shared_ptr<TDatabaseFeedManager>& databaseFeedManager) {};
    virtual ~TFakeAlertClearBuilder() = default;

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Mocked context data
     * @return std::shared_ptr<std::vector<std::string>>
     */
    std::shared_ptr<std::vector<std::string>> handleRequest(std::shared_ptr<std::vector<std::string>> data) override
    {
        data->push_back("alertClearBuilder");
        return AbstractHandler<std::shared_ptr<std::vector<std::string>>>::handleRequest(std::move(data));
    }
};
using FakeAlertClearBuilder = TFakeAlertClearBuilder<>;

/**
 * @brief OsScanner fake class.
 */
template<typename TDatabaseFeedManager = MockDatabaseFeedManager>
class TFakeOsScanner : public AbstractHandler<std::shared_ptr<std::vector<std::string>>>
{
public:
    /**
     * @brief Construct a new TFakeOsScanner object.
     *
     * @param databaseFeedManager TDatabaseFeedManager instance.
     */
    TFakeOsScanner(std::shared_ptr<TDatabaseFeedManager> databaseFeedManager) {};
    virtual ~TFakeOsScanner() = default;

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Mocked context data
     * @return std::shared_ptr<std::vector<std::string>>
     */
    std::shared_ptr<std::vector<std::string>> handleRequest(std::shared_ptr<std::vector<std::string>> data) override
    {
        data->push_back("osScanner");
        return AbstractHandler<std::shared_ptr<std::vector<std::string>>>::handleRequest(std::move(data));
    }
};
using FakeOsScanner = TFakeOsScanner<>;

/**
 * @brief CleanInventory fake class.
 */
class FakeCleanInventory : public AbstractHandler<std::shared_ptr<std::vector<std::string>>>
{
public:
    /**
     * @brief Construct a new Mock GlobalDbFetch object.
     * @param inventoryDatabase RocksDBWrapper instance for inventory storage.
     * @param subOrchestration AbstractHandler instance.
     */
    FakeCleanInventory(Utils::RocksDBWrapper& inventoryDatabase,
                       std::shared_ptr<AbstractHandler<std::shared_ptr<std::vector<std::string>>>> subOrchestration) {};
    virtual ~FakeCleanInventory() = default;

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Mocked context data
     * @return std::shared_ptr<std::vector<std::string>>
     */
    std::shared_ptr<std::vector<std::string>> handleRequest(std::shared_ptr<std::vector<std::string>> data) override
    {
        data->push_back("cleanInventory");
        return AbstractHandler<std::shared_ptr<std::vector<std::string>>>::handleRequest(std::move(data));
    }
};

/**
 * @brief EventDeleteInventory fake class.
 */
class FakeEventDeleteInventory : public AbstractHandler<std::shared_ptr<std::vector<std::string>>>
{
public:
    /**
     * @brief Construct a new FakeEventDeleteInventory object
     *
     * @param inventoryDatabase RocksDBWrapper instance for inventory storage..
     */
    FakeEventDeleteInventory(Utils::RocksDBWrapper& inventoryDatabase) {};
    virtual ~FakeEventDeleteInventory() = default;

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Mocked context data
     * @return std::shared_ptr<std::vector<std::string>>
     */
    std::shared_ptr<std::vector<std::string>> handleRequest(std::shared_ptr<std::vector<std::string>> data) override
    {
        data->push_back("eventDeleteInventory");
        return AbstractHandler<std::shared_ptr<std::vector<std::string>>>::handleRequest(std::move(data));
    }
};

/**
 * @brief EventInsertInventory fake class.
 */
class FakeEventInsertInventory : public AbstractHandler<std::shared_ptr<std::vector<std::string>>>
{
public:
    /**
     * @brief Construct a new FakeEventInsertInventory object
     *
     * @param inventoryDatabase RocksDBWrapper instance for inventory storage..
     */
    FakeEventInsertInventory(Utils::RocksDBWrapper& inventoryDatabase) {};
    virtual ~FakeEventInsertInventory() = default;

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Mocked context data
     * @return std::shared_ptr<std::vector<std::string>>
     */
    std::shared_ptr<std::vector<std::string>> handleRequest(std::shared_ptr<std::vector<std::string>> data)
    {
        data->push_back("eventInsertInventory");
        return AbstractHandler<std::shared_ptr<std::vector<std::string>>>::handleRequest(std::move(data));
    }
};

/**
 * @brief ScanInventorySync fake class.
 */
class FakeScanInventorySync : public AbstractHandler<std::shared_ptr<std::vector<std::string>>>
{
public:
    /**
     * @brief Construct a new Mock Inventory Sync object
     *
     * @param inventoryDatabase RocksDBWrapper instance for inventory storage..
     */
    FakeScanInventorySync(Utils::RocksDBWrapper& inventoryDatabase) {};
    virtual ~FakeScanInventorySync() = default;

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Mocked context data
     * @return std::shared_ptr<std::vector<std::string>>
     */
    std::shared_ptr<std::vector<std::string>> handleRequest(std::shared_ptr<std::vector<std::string>> data) override
    {
        data->push_back("scanInventorySync");
        return AbstractHandler<std::shared_ptr<std::vector<std::string>>>::handleRequest(std::move(data));
    }
};

/**
 * @brief ClearSendReport fake class.
 */
class FakeClearSendReport : public AbstractHandler<std::shared_ptr<std::vector<std::string>>>
{
public:
    /**
     * @brief Construct a new Mock Send Report object
     *
     * @param reportDispatcher Report dispatcher instance.
     */
    FakeClearSendReport(std::shared_ptr<ReportDispatcher> reportDispatcher) {};
    virtual ~FakeClearSendReport() = default;

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Mocked context data
     * @return std::shared_ptr<std::vector<std::string>>
     */
    std::shared_ptr<std::vector<std::string>> handleRequest(std::shared_ptr<std::vector<std::string>> data) override
    {
        data->push_back("clearSendReport");
        return AbstractHandler<std::shared_ptr<std::vector<std::string>>>::handleRequest(std::move(data));
    }
};

/**
 * @brief EventSendReport fake class.
 */
class FakeEventSendReport : public AbstractHandler<std::shared_ptr<std::vector<std::string>>>
{
public:
    /**
     * @brief Construct a new Mock Send Report object
     *
     * @param reportDispatcher Report dispatcher instance.
     */
    FakeEventSendReport(std::shared_ptr<ReportDispatcher> reportDispatcher) {};
    virtual ~FakeEventSendReport() = default;

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Mocked context data
     * @return std::shared_ptr<std::vector<std::string>>
     */
    std::shared_ptr<std::vector<std::string>> handleRequest(std::shared_ptr<std::vector<std::string>> data) override
    {
        data->push_back("eventSendReport");
        return AbstractHandler<std::shared_ptr<std::vector<std::string>>>::handleRequest(std::move(data));
    }
};

/**
 * @brief ResultIndexer fake class.
 */
template<typename TIndexerConnector = MockIndexerConnector>
class TFakeResultIndexer : public AbstractHandler<std::shared_ptr<std::vector<std::string>>>
{
public:
    /**
     * @brief Construct a new TFakeResultIndexer object
     *
     * @param indexerConnector TIndexerConnector instance.
     */
    TFakeResultIndexer(std::shared_ptr<TIndexerConnector> indexerConnector) {};
    virtual ~TFakeResultIndexer() = default;

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Mocked context data
     * @return std::shared_ptr<std::vector<std::string>>
     */
    std::shared_ptr<std::vector<std::string>> handleRequest(std::shared_ptr<std::vector<std::string>> data) override
    {
        data->push_back("resultIndexer");
        return AbstractHandler<std::shared_ptr<std::vector<std::string>>>::handleRequest(std::move(data));
    }
};

using FakeResultIndexer = TFakeResultIndexer<>;

/**
 * @brief FetchFromGlobalDb fake class.
 */
class FakeFetchFromGlobalDb : public AbstractHandler<std::shared_ptr<std::vector<std::string>>>
{
public:
    /**
     * @brief Construct a new Mock GlobalDbFetch object.
     */
    FakeFetchFromGlobalDb() {};
    virtual ~FakeFetchFromGlobalDb() = default;

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Mocked context data
     * @return std::shared_ptr<std::vector<std::string>>
     */
    std::shared_ptr<std::vector<std::string>> handleRequest(std::shared_ptr<std::vector<std::string>> data) override
    {
        data->push_back("fetchFromGlobalDB");
        return AbstractHandler<std::shared_ptr<std::vector<std::string>>>::handleRequest(std::move(data));
    }
};

/**
 * @brief CleanAgentInventory fake class.
 */
class FakeCleanAgentInventory : public AbstractHandler<std::shared_ptr<std::vector<std::string>>>
{
public:
    /**
     * @brief Construct a new Mock GlobalDbFetch object.
     * @param inventoryDatabase RocksDBWrapper instance for inventory storage.
     * @param subOrchestration AbstractHandler instance.
     */
    FakeCleanAgentInventory(
        Utils::RocksDBWrapper& inventoryDatabase,
        std::shared_ptr<AbstractHandler<std::shared_ptr<std::vector<std::string>>>> subOrchestration) {};
    virtual ~FakeCleanAgentInventory() = default;

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Mocked context data
     * @return std::shared_ptr<std::vector<std::string>>
     */
    std::shared_ptr<std::vector<std::string>> handleRequest(std::shared_ptr<std::vector<std::string>> data) override
    {
        data->push_back("cleanAgentInventory");
        return AbstractHandler<std::shared_ptr<std::vector<std::string>>>::handleRequest(std::move(data));
    }
};

/**
 *@brief QueryAllPackages fake class.
 */
class FakeQueryPkgsAgt : public AbstractHandler<std::shared_ptr<std::vector<std::string>>>
{
public:
    /**
     * @brief Construct a new Mock GlobalDbFetch object.
     * @param packageInsertOrchestration package orchestration instance.
     */
    FakeQueryPkgsAgt(
        std::shared_ptr<AbstractHandler<std::shared_ptr<std::vector<std::string>>>> packageInsertOrchestration) {};
    virtual ~FakeQueryPkgsAgt() = default;

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Mocked context data
     * @return std::shared_ptr<std::vector<std::string>>
     */
    std::shared_ptr<std::vector<std::string>> handleRequest(std::shared_ptr<std::vector<std::string>> data) override
    {
        data->push_back("queryAllPackages");
        return AbstractHandler<std::shared_ptr<std::vector<std::string>>>::handleRequest(std::move(data));
    }
};

/*
 * @brief Test the chain creation for packages.
 */
TEST_F(FactoryOrchestratorTest, TestScannerTypePackageInsert)
{
    // Create the orchestrator for PackageInsert.
    std::shared_ptr<AbstractHandler<std::shared_ptr<std::vector<std::string>>>> orchestration =
        TFactoryOrchestrator<FakePackageScanner,
                             FakeEventPackageAlertDetailsBuilder,
                             FakeScanOsAlertDetailsBuilder,
                             FakeEventDetailsBuilder,
                             FakeAlertClearBuilder,
                             FakeOsScanner,
                             FakeCleanInventory,
                             FakeEventDeleteInventory,
                             FakeEventInsertInventory,
                             FakeScanInventorySync,
                             FakeClearSendReport,
                             FakeEventSendReport,
                             FakeResultIndexer,
                             MockDatabaseFeedManager,
                             MockIndexerConnector,
                             std::vector<std::string>,
                             FakeFetchFromGlobalDb,
                             FakeCleanAgentInventory,
                             FakeQueryPkgsAgt>::create(ScannerType::PackageInsert,
                                                       NULL,
                                                       NULL,
                                                       *m_inventoryDatabase,
                                                       NULL);

    std::shared_ptr<std::vector<std::string>> context = std::make_shared<std::vector<std::string>>();

    EXPECT_NO_THROW(orchestration->handleRequest(context));
    EXPECT_EQ(context->size(), 6);
    EXPECT_EQ(context->at(0), "packageScanner");
    EXPECT_EQ(context->at(1), "eventInsertInventory");
    EXPECT_EQ(context->at(2), "eventDetailsBuilder");
    EXPECT_EQ(context->at(3), "eventPackageAlertDetailsBuilder");
    EXPECT_EQ(context->at(4), "eventSendReport");
    EXPECT_EQ(context->at(5), "resultIndexer");
}

/*
 * @brief Test the chain deletion for packages.
 */
TEST_F(FactoryOrchestratorTest, TestScannerTypePackageDelete)
{
    // Create the orchestrator for PackageDelete.
    std::shared_ptr<AbstractHandler<std::shared_ptr<std::vector<std::string>>>> orchestration =
        TFactoryOrchestrator<FakePackageScanner,
                             FakeEventPackageAlertDetailsBuilder,
                             FakeScanOsAlertDetailsBuilder,
                             FakeEventDetailsBuilder,
                             FakeAlertClearBuilder,
                             FakeOsScanner,
                             FakeCleanInventory,
                             FakeEventDeleteInventory,
                             FakeEventInsertInventory,
                             FakeScanInventorySync,
                             FakeClearSendReport,
                             FakeEventSendReport,
                             FakeResultIndexer,
                             MockDatabaseFeedManager,
                             MockIndexerConnector,
                             std::vector<std::string>,
                             FakeFetchFromGlobalDb,
                             FakeCleanAgentInventory,
                             FakeQueryPkgsAgt>::create(ScannerType::PackageDelete,
                                                       NULL,
                                                       NULL,
                                                       *m_inventoryDatabase,
                                                       NULL);

    std::shared_ptr<std::vector<std::string>> context = std::make_shared<std::vector<std::string>>();

    EXPECT_NO_THROW(orchestration->handleRequest(context));
    EXPECT_EQ(context->size(), 4);
    EXPECT_EQ(context->at(0), "eventDeleteInventory");
    EXPECT_EQ(context->at(1), "eventPackageAlertDetailsBuilder");
    EXPECT_EQ(context->at(2), "eventSendReport");
    EXPECT_EQ(context->at(3), "resultIndexer");
}

/*
 * @brief Test the chain creation for packages.
 */
TEST_F(FactoryOrchestratorTest, TestScannerTypeIntegrityClear)
{
    // Create the orchestrator for IntegrityClear.
    std::shared_ptr<AbstractHandler<std::shared_ptr<std::vector<std::string>>>> orchestration =
        TFactoryOrchestrator<FakePackageScanner,
                             FakeEventPackageAlertDetailsBuilder,
                             FakeScanOsAlertDetailsBuilder,
                             FakeEventDetailsBuilder,
                             FakeAlertClearBuilder,
                             FakeOsScanner,
                             FakeCleanInventory,
                             FakeEventDeleteInventory,
                             FakeEventInsertInventory,
                             FakeScanInventorySync,
                             FakeClearSendReport,
                             FakeEventSendReport,
                             FakeResultIndexer,
                             MockDatabaseFeedManager,
                             MockIndexerConnector,
                             std::vector<std::string>,
                             FakeFetchFromGlobalDb,
                             FakeCleanAgentInventory,
                             FakeQueryPkgsAgt>::create(ScannerType::IntegrityClear,
                                                       NULL,
                                                       NULL,
                                                       *m_inventoryDatabase,
                                                       NULL);

    std::shared_ptr<std::vector<std::string>> context = std::make_shared<std::vector<std::string>>();

    EXPECT_NO_THROW(orchestration->handleRequest(context));
    EXPECT_EQ(context->size(), 3);
    EXPECT_EQ(context->at(0), "cleanAgentInventory");
    EXPECT_EQ(context->at(1), "alertClearBuilder");
    EXPECT_EQ(context->at(2), "clearSendReport");
}

/*
 * @brief Test the chain creation for os.
 */
TEST_F(FactoryOrchestratorTest, TestScannerTypeOs)
{
    // Create the orchestrator for Os.
    std::shared_ptr<AbstractHandler<std::shared_ptr<std::vector<std::string>>>> orchestration =
        TFactoryOrchestrator<FakePackageScanner,
                             FakeEventPackageAlertDetailsBuilder,
                             FakeScanOsAlertDetailsBuilder,
                             FakeEventDetailsBuilder,
                             FakeAlertClearBuilder,
                             FakeOsScanner,
                             FakeCleanInventory,
                             FakeEventDeleteInventory,
                             FakeEventInsertInventory,
                             FakeScanInventorySync,
                             FakeClearSendReport,
                             FakeEventSendReport,
                             FakeResultIndexer,
                             MockDatabaseFeedManager,
                             MockIndexerConnector,
                             std::vector<std::string>,
                             FakeFetchFromGlobalDb,
                             FakeCleanAgentInventory,
                             FakeQueryPkgsAgt>::create(ScannerType::Os, NULL, NULL, *m_inventoryDatabase, NULL);

    std::shared_ptr<std::vector<std::string>> context = std::make_shared<std::vector<std::string>>();

    EXPECT_NO_THROW(orchestration->handleRequest(context));
    EXPECT_EQ(context->size(), 6);
    EXPECT_EQ(context->at(0), "osScanner");
    EXPECT_EQ(context->at(1), "scanInventorySync");
    EXPECT_EQ(context->at(2), "eventDetailsBuilder");
    EXPECT_EQ(context->at(3), "scanOsAlertDetailsBuilder");
    EXPECT_EQ(context->at(4), "eventSendReport");
    EXPECT_EQ(context->at(5), "resultIndexer");
}

/**
 * @brief Test the chain creation for CleanupAllData.
 */
TEST_F(FactoryOrchestratorTest, TestCreationCleanUpAllData)
{
    // Create the orchestrator for CleanUpAllDAta.
    std::shared_ptr<AbstractHandler<std::shared_ptr<std::vector<std::string>>>> orchestration =
        TFactoryOrchestrator<FakePackageScanner,
                             FakeEventPackageAlertDetailsBuilder,
                             FakeScanOsAlertDetailsBuilder,
                             FakeEventDetailsBuilder,
                             FakeAlertClearBuilder,
                             FakeOsScanner,
                             FakeCleanInventory,
                             FakeEventDeleteInventory,
                             FakeEventInsertInventory,
                             FakeScanInventorySync,
                             FakeClearSendReport,
                             FakeEventSendReport,
                             FakeResultIndexer,
                             MockDatabaseFeedManager,
                             MockIndexerConnector,
                             std::vector<std::string>,
                             FakeFetchFromGlobalDb,
                             FakeCleanAgentInventory,
                             FakeQueryPkgsAgt>::create(ScannerType::CleanupAllData,
                                                       NULL,
                                                       NULL,
                                                       *m_inventoryDatabase,
                                                       NULL);

    std::shared_ptr<std::vector<std::string>> context = std::make_shared<std::vector<std::string>>();

    EXPECT_NO_THROW(orchestration->handleRequest(context));
    EXPECT_EQ(context->size(), 1);
    EXPECT_EQ(context->at(0), "cleanInventory");
}

/**
 * @brief Test the chain creation for ReScanAllAgents.
 */
TEST_F(FactoryOrchestratorTest, TestCreationReScanAllAgents)
{
    // Create the orchestrator for ReScanAllAgents.
    std::shared_ptr<AbstractHandler<std::shared_ptr<std::vector<std::string>>>> orchestration =
        TFactoryOrchestrator<FakePackageScanner,
                             FakeEventPackageAlertDetailsBuilder,
                             FakeScanOsAlertDetailsBuilder,
                             FakeEventDetailsBuilder,
                             FakeAlertClearBuilder,
                             FakeOsScanner,
                             FakeCleanInventory,
                             FakeEventDeleteInventory,
                             FakeEventInsertInventory,
                             FakeScanInventorySync,
                             FakeClearSendReport,
                             FakeEventSendReport,
                             FakeResultIndexer,
                             MockDatabaseFeedManager,
                             MockIndexerConnector,
                             std::vector<std::string>,
                             FakeFetchFromGlobalDb,
                             FakeCleanAgentInventory,
                             FakeQueryPkgsAgt>::create(ScannerType::ReScanAllAgents,
                                                       NULL,
                                                       NULL,
                                                       *m_inventoryDatabase,
                                                       NULL);

    std::shared_ptr<std::vector<std::string>> context = std::make_shared<std::vector<std::string>>();

    EXPECT_NO_THROW(orchestration->handleRequest(context));
    EXPECT_EQ(context->size(), 2);
    EXPECT_EQ(context->at(0), "fetchFromGlobalDB");
    EXPECT_EQ(context->at(1), "queryAllPackages");
}

/**
 * @brief Test the chain creation for ReScanSingleAgent.
 */
TEST_F(FactoryOrchestratorTest, TestCreationReScanSingleAgent)
{
    // Create the orchestrator for ReScanSingleAgent.
    std::shared_ptr<AbstractHandler<std::shared_ptr<std::vector<std::string>>>> orchestration =
        TFactoryOrchestrator<FakePackageScanner,
                             FakeEventPackageAlertDetailsBuilder,
                             FakeScanOsAlertDetailsBuilder,
                             FakeEventDetailsBuilder,
                             FakeAlertClearBuilder,
                             FakeOsScanner,
                             FakeCleanInventory,
                             FakeEventDeleteInventory,
                             FakeEventInsertInventory,
                             FakeScanInventorySync,
                             FakeClearSendReport,
                             FakeEventSendReport,
                             FakeResultIndexer,
                             MockDatabaseFeedManager,
                             MockIndexerConnector,
                             std::vector<std::string>,
                             FakeFetchFromGlobalDb,
                             FakeCleanAgentInventory,
                             FakeQueryPkgsAgt>::create(ScannerType::ReScanSingleAgent,
                                                       NULL,
                                                       NULL,
                                                       *m_inventoryDatabase,
                                                       NULL);

    std::shared_ptr<std::vector<std::string>> context = std::make_shared<std::vector<std::string>>();

    EXPECT_NO_THROW(orchestration->handleRequest(context));
    EXPECT_EQ(context->size(), 2);
    EXPECT_EQ(context->at(0), "cleanAgentInventory");
    EXPECT_EQ(context->at(1), "queryAllPackages");
}

TEST_F(FactoryOrchestratorTest, TestCreationCleanUpAgentData)
{
    // Create the orchestrator for ReScanSingleAgent.
    std::shared_ptr<AbstractHandler<std::shared_ptr<std::vector<std::string>>>> orchestration =
        TFactoryOrchestrator<FakePackageScanner,
                             FakeEventPackageAlertDetailsBuilder,
                             FakeScanOsAlertDetailsBuilder,
                             FakeEventDetailsBuilder,
                             FakeAlertClearBuilder,
                             FakeOsScanner,
                             FakeCleanInventory,
                             FakeEventDeleteInventory,
                             FakeEventInsertInventory,
                             FakeScanInventorySync,
                             FakeClearSendReport,
                             FakeEventSendReport,
                             FakeResultIndexer,
                             MockDatabaseFeedManager,
                             MockIndexerConnector,
                             std::vector<std::string>,
                             FakeFetchFromGlobalDb,
                             FakeCleanAgentInventory,
                             FakeQueryPkgsAgt>::create(ScannerType::CleanupAgentData,
                                                       NULL,
                                                       NULL,
                                                       *m_inventoryDatabase,
                                                       NULL);

    std::shared_ptr<std::vector<std::string>> context = std::make_shared<std::vector<std::string>>();

    EXPECT_NO_THROW(orchestration->handleRequest(context));
    EXPECT_EQ(context->size(), 1);
    EXPECT_EQ(context->at(0), "cleanAgentInventory");
}

/*
 * @brief Test the creation of an invalid scanner.
 */
TEST_F(FactoryOrchestratorTest, TestCreationInvalidScannerType)
{
    // Create the orchestrator with invalid ScannerType.
    ScannerType invalidScannerType {-1};

    try
    {
        TFactoryOrchestrator<FakePackageScanner,
                             FakeEventPackageAlertDetailsBuilder,
                             FakeScanOsAlertDetailsBuilder,
                             FakeEventDetailsBuilder,
                             FakeAlertClearBuilder,
                             FakeOsScanner,
                             FakeCleanInventory,
                             FakeEventDeleteInventory,
                             FakeEventInsertInventory,
                             FakeScanInventorySync,
                             FakeClearSendReport,
                             FakeEventSendReport,
                             FakeResultIndexer,
                             MockDatabaseFeedManager,
                             MockIndexerConnector,
                             std::vector<std::string>,
                             FakeFetchFromGlobalDb,
                             FakeCleanAgentInventory,
                             FakeQueryPkgsAgt>::create(invalidScannerType, NULL, NULL, *m_inventoryDatabase, NULL);
    }
    catch (const std::runtime_error& e)
    {
        EXPECT_STREQ(e.what(), "Invalid scanner type");
    }
    catch (...)
    {
        FAIL() << "Expected std::runtime_error";
    }
}
