/*
 * Wazuh Vulnerability scanner
 * Copyright (C) 2015, Wazuh Inc.
 * September 26, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _DATABASE_FEED_MANAGER_TRAPS_HPP
#define _DATABASE_FEED_MANAGER_TRAPS_HPP

#include "json.hpp"
#include "mockContentRegister.hpp"
#include "mockIndexerConnector.hpp"
#include "mockPolicyManager.hpp"
#include "mockRouterSubscriber.hpp"
#include "observer.hpp"
#include "singleton.hpp"

#include <functional>
#include <memory>
#include <string>
#include <unordered_map>
#include <vector>

extern std::shared_ptr<IndexerConnectorMock> pIndexerConnectorMock;
extern std::shared_ptr<PolicyManagerMock> pPolicyManagerMock;
extern std::shared_ptr<ContentRegisterMock> pContentRegisterMock;
extern std::shared_ptr<RouterSubscriberMock> pRouterSubscriberMock;

/**
 * @brief IndexerConnector trap class.
 *
 */
class IndexerConnectorTrap
{
public:
    /**
     * @brief Construct a new Indexer Connector Trap object
     *
     */
    IndexerConnectorTrap() = default;

    /**
     * @brief Destroy the Indexer Connector Trap object
     *
     */
    virtual ~IndexerConnectorTrap() = default;

    /**
     * @brief Publish a message into the queue map.
     *
     * @param message Message to be published.
     */
    void publish(const std::string& message) const
    {
        pIndexerConnectorMock->publish(message);
    }
};

/**
 * @brief PolicyManager trap class.
 *
 */
class PolicyManagerTrap : public Singleton<PolicyManagerTrap>
{
public:
    /**
     * @brief Construct a new Policy Manager Trap object
     *
     */
    PolicyManagerTrap() = default;

    /**
     * @brief Destroy the Policy Manager Trap object
     *
     */
    virtual ~PolicyManagerTrap() = default;

    /**
     * @brief Initializes manager.
     *
     * @param configuration Manager configuration.
     */
    void initialize(const nlohmann::json& configuration)
    {
        pPolicyManagerMock->initialize(configuration);
    }

    /**
     * @brief Loads configuration settings from a JSON object.
     *
     * This function takes a JSON object containing configuration settings and
     * processes them for use by the policy manager's module.
     *
     * @param configuration The JSON object containing configuration settings.
     */
    void loadConfiguration(const nlohmann::json& configuration)
    {
        pPolicyManagerMock->loadConfiguration(configuration);
    }

    /**
     * @brief Validates the configuration settings of the vulnerability-detection's module.
     *
     * This function checks if the configuration settings are valid and conform
     * to the expected format and values. It throw an exception
     * if some value in the configuration is invalid.
     *
     * @throws std::runtime If some configuration is invalid.
     *
     */
    void validateConfiguration()
    {
        pPolicyManagerMock->validateConfiguration();
    }

    /**
     * @brief Validates and configures the vulnerability detection based on the provided JSON object.
     *
     * This function takes a JSON object as input, which is expected to contain configuration
     * information for vulnerability detection. It validates the JSON object to ensure it contains the
     * required fields and has valid values. If the validation passes, no exception is thrown.
     *
     * @param vdObj A constant reference to a JSON object representing the vulnerability detection's configuration.
     *
     * @note This function assumes that the provided JSON object follows a specific format.
     * @note If validation fails, this function throws std::runtime exception.
     */
    void validateAndConfigureVulnerabilityDetection(const nlohmann::json& vdObj)
    {
        pPolicyManagerMock->validateAndConfigureVulnerabilityDetection(vdObj);
    }

    /**
     * @brief Validates and configures the indexer based on the provided JSON object.
     *
     * This function takes a JSON object as input, which is expected to contain configuration
     * information for the indexer. It validates the JSON object to ensure it contains the
     * required fields and has valid values, based on the previous configuration of the vulnerability detection.
     * If the validation passes, no exception is thrown.
     *
     * @param idObj A constant reference to a JSON object representing the indexer's configuration.
     *
     * @note This function assumes that the provided JSON object follows a specific format.
     * @note If validation fails, this function throws std::runtime exception.
     */
    void validateAndConfigureIndexer(const nlohmann::json& idObj)
    {
        pPolicyManagerMock->validateAndConfigureIndexer(idObj);
    }

    /**
     * @brief Adds subscriber.
     *
     * @param subscriber Subscriber to be added.
     */
    void addSubscriber(std::shared_ptr<Observer<nlohmann::json&>> subscriber)
    {
        pPolicyManagerMock->addSubscriber(subscriber);
    }

    /**
     * @brief Removes subscriber.
     *
     * @param observerId Observer ID.
     */
    void removeSubscriber(const std::string& observerId)
    {
        pPolicyManagerMock->removeSubscriber(observerId);
    }

    /**
     * @brief Get the Updater Configuration object
     *
     * @return nlohmann::json
     */
    nlohmann::json getUpdaterConfiguration() const
    {
        return pPolicyManagerMock->getUpdaterConfiguration();
    }

    /**
     * @brief Get the Exclusions object
     *
     * @return nlohmann::json
     */
    nlohmann::json getExclusions() const
    {
        return pPolicyManagerMock->getExclusions();
    }

    /**
     * @brief Get the Indexer Configuration object
     *
     * @return nlohmann::json
     */
    nlohmann::json getIndexerConfiguration() const
    {
        return pPolicyManagerMock->getIndexerConfiguration();
    }

    /**
     * @brief Get the Vulnerability Detection object
     *
     * @return nlohmann::json
     */
    nlohmann::json getVulnerabilityDetection() const
    {
        return pPolicyManagerMock->getVulnerabilityDetection();
    }

    /**
     * @brief Get vulnerability detection status.
     *
     * @return true if enabled or false if not.
     */
    bool isVulnerabilityDetectionEnabled() const
    {
        return pPolicyManagerMock->isVulnerabilityDetectionEnabled();
    }

    /**
     * @brief Get indexer status.
     *
     * @return true if enabled or false if not.
     */
    bool isIndexerEnabled() const
    {
        return pPolicyManagerMock->isIndexerEnabled();
    }

    /**
     * @brief Get the Feed Url object
     *
     * @return std::string
     */
    std::string getFeedUrl() const
    {
        return pPolicyManagerMock->getFeedUrl();
    }

    /**
     * @brief Get feed url.
     *
     * @return std::string feedUrl.
     */
    long getFeedUpdateTime() const
    {
        return pPolicyManagerMock->getFeedUpdateTime();
    }

    /**
     * @brief Get the Host List object
     *
     * @return std::unordered_set<std::string>
     */
    std::unordered_set<std::string> getHostList() const
    {
        return pPolicyManagerMock->getHostList();
    }

    /**
     * @brief Get certificate authorities.
     *
     * @return std::unordered_set caList.
     */
    std::unordered_set<std::string> getCAList() const
    {
        return pPolicyManagerMock->getCAList();
    }

    /**
     * @brief Get the Username object
     *
     * @return std::string
     */
    std::string getUsername() const
    {
        return pPolicyManagerMock->getUsername();
    }

    /**
     * @brief Get the Password object
     *
     * @return std::string
     */
    std::string getPassword() const
    {
        return pPolicyManagerMock->getPassword();
    }

    /**
     * @brief Get the Certificate object
     *
     * @return std::string
     */
    std::string getCertificate() const
    {
        return pPolicyManagerMock->getCertificate();
    }

    /**
     * @brief Get the Key object
     *
     * @return std::string
     */
    std::string getKey() const
    {
        return pPolicyManagerMock->getKey();
    }

    /**
     * @brief Get the Apikey object
     *
     * @return std::string
     */
    std::string getApikey() const
    {
        return pPolicyManagerMock->getApikey();
    }
};

/**
 * @brief ContentRegister trap class.
 *
 */
class ContentRegisterTrap
{
public:
    /**
     * @brief Construct a new Content Register Trap object
     *
     * @param topicName
     * @param parameters
     */
    ContentRegisterTrap(std::string topicName, const nlohmann::json parameters) {};

    /**
     * @brief Destroy the Content Register Trap object
     *
     */
    virtual ~ContentRegisterTrap() = default;

    /**
     * @brief Changes schedular interval to a new value.
     *
     * @param newInterval New value to set.
     */
    void changeSchedulerInterval(size_t newInterval)
    {
        pContentRegisterMock->changeSchedulerInterval(newInterval);
    }
};

/**
 * @brief RouterSubscriber trap class.
 *
 */
class RouterSubscriberTrap
{
public:
    /**
     * @brief Construct a new Router Subscriber Trap object
     *
     * @param topicName
     * @param subscriberId
     * @param isLocal
     */
    RouterSubscriberTrap(std::string topicName, std::string subscriberId, const bool isLocal = true) {};

    /**
     * @brief Destroy the Router Subscriber Trap object
     *
     */
    virtual ~RouterSubscriberTrap() = default;

    /**
     * @brief Adds subscriber to the list.
     *
     * @param callback Subscriber update callback.
     */
    void subscribe(const std::function<void(const std::vector<char>&)>& callback)
    {
        pRouterSubscriberMock->subscribe(callback);
    }
};

#endif // _DATABASE_FEED_MANAGER_TRAPS_HPP
