/*
 * Wazuh Vulnerability scanner
 * Copyright (C) 2015, Wazuh Inc.
 * September 26, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _DATABASE_FEED_MANAGER_TRAPS_HPP
#define _DATABASE_FEED_MANAGER_TRAPS_HPP

#include "mockContentRegister.hpp"
#include "mockIndexerConnector.hpp"
#include "json.hpp"
#include "observer.hpp"
#include "mockPolicyManager.hpp"
#include "mockRouterSubscriber.hpp"
#include "singleton.hpp"

#include <functional>
#include <memory>
#include <string>
#include <unordered_map>
#include <vector>

extern std::shared_ptr<IndexerConnectorMock> pIndexerConnectorMock;
extern std::shared_ptr<PolicyManagerMock> pPolicyManagerMock;
extern std::shared_ptr<ContentRegisterMock> pContentRegisterMock;
extern std::shared_ptr<RouterSubscriberMock> pRouterSubscriberMock;

class IndexerConnectorTrap
{
public:
    IndexerConnectorTrap() = default;
    virtual ~IndexerConnectorTrap() = default;

    void publish(const std::string& message) const
    {
        pIndexerConnectorMock->publish(message);
    }
};

class PolicyManagerTrap : public Singleton<PolicyManagerTrap>
{
public:
    PolicyManagerTrap() = default;
    virtual ~PolicyManagerTrap() = default;

    void initialize(const nlohmann::json& configuration)
    {
        pPolicyManagerMock->initialize(configuration);
    }

    void loadConfiguration(const nlohmann::json& configuration)
    {
        pPolicyManagerMock->loadConfiguration(configuration);
    }

    void validateConfiguration()
    {
        pPolicyManagerMock->validateConfiguration();
    }

    void validateAndConfigureVulnerabilityDetection(const nlohmann::json& vdObj)
    {
        pPolicyManagerMock->validateAndConfigureVulnerabilityDetection(vdObj);
    }

    void validateAndConfigureIndexer(const nlohmann::json& idObj)
    {
        pPolicyManagerMock->validateAndConfigureIndexer(idObj);
    }

    void addSubscriber(std::shared_ptr<Observer<nlohmann::json&>> subscriber)
    {
        pPolicyManagerMock->addSubscriber(subscriber);
    }

    void removeSubscriber(const std::string& observerId)
    {
        pPolicyManagerMock->removeSubscriber(observerId);
    }

    nlohmann::json getUpdaterConfiguration() const
    {
        return pPolicyManagerMock->getUpdaterConfiguration();
    }

    nlohmann::json getExclusions() const
    {
        return pPolicyManagerMock->getExclusions();
    }

    nlohmann::json getIndexerConfiguration() const
    {
        return pPolicyManagerMock->getIndexerConfiguration();
    }

    nlohmann::json getVulnerabilityDetection() const
    {
        return pPolicyManagerMock->getVulnerabilityDetection();
    }

    bool isVulnerabilityDetectionEnabled() const
    {
        return pPolicyManagerMock->isVulnerabilityDetectionEnabled();
    }

    bool isIndexerEnabled() const
    {
        return pPolicyManagerMock->isIndexerEnabled();
    }

    std::string getFeedUrl() const
    {
        return pPolicyManagerMock->getFeedUrl();
    }

    long getFeedUpdateTime() const
    {
        return pPolicyManagerMock->getFeedUpdateTime();
    }

    std::unordered_set<std::string> getHostList() const
    {
        return pPolicyManagerMock->getHostList();
    }

    std::unordered_set<std::string> getCAList() const
    {
        return pPolicyManagerMock->getCAList();
    }

    std::string getUsername() const
    {
        return pPolicyManagerMock->getUsername();
    }

    std::string getPassword() const
    {
        return pPolicyManagerMock->getPassword();
    }

    std::string getCertificate() const
    {
        return pPolicyManagerMock->getCertificate();
    }

    std::string getKey() const
    {
        return pPolicyManagerMock->getKey();
    }

    std::string getApikey() const
    {
        return pPolicyManagerMock->getApikey();
    }
};

class ContentRegisterTrap
{
public:
    ContentRegisterTrap(std::string topicName, const nlohmann::json parameters) {};
    virtual ~ContentRegisterTrap() = default;

    void changeSchedulerInterval(size_t newInterval)
    {
        pContentRegisterMock->changeSchedulerInterval(newInterval);
    }
};

class RouterSubscriberTrap
{
public:
    RouterSubscriberTrap(std::string topicName, std::string subscriberId, const bool isLocal = true) {};
    virtual ~RouterSubscriberTrap() = default;

    void subscribe(const std::function<void(const std::vector<char>&)>& callback)
    {
        pRouterSubscriberMock->subscribe(callback);
    }
};

#endif // _DATABASE_FEED_MANAGER_TRAPS_HPP
