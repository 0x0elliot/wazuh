/*
 * Wazuh databaseFeedManager tests.
 * Copyright (C) 2015, Wazuh Inc.
 * September 19, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "databaseFeedManager_tests.hpp"
#include "MockContentRegister.hpp"
#include "MockIndexerConnector.hpp"
#include "MockPolicyManager.hpp"
#include "MockRouterSubscriber.hpp"
#include "TrampolineContentRegister.hpp"
#include "TrampolineIndexerConnector.hpp"
#include "TrampolinePolicyManager.hpp"
#include "TrampolineRouterSuscribe.hpp"
#include "flatbuffers/flatbuffer_builder.h"
#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/idl.h"
#include "scanContext.hpp"
#include <unordered_map>

std::shared_ptr<MockContentRegister> spContentRegisterMock;
std::shared_ptr<MockIndexerConnector> spIndexerConnectorMock;
std::shared_ptr<MockPolicyManager> spPolicyManagerMock;
std::shared_ptr<MockRouterSubscriber> spRouterSubscriberMock;

using ::testing::_;
using ::testing::Return;

const std::string flatbufferSchema {FLATBUFFER_SCHEMAS_DIR "/scanVulnerabilityCandidate.fbs"};

const std::string msgStr {
    "random_string_:{\"data\":{\"architecture\":\"amd64\",\"checksum\":\"f2cacd7658244c009fc10aef49044865c24a7aff\","
    "\"description\":\"File type determination library using \\\"magic\\\" numbers (compiled magic "
    "file)\",\"format\":\"deb\",\"groups\":\"libs\",\"install_time\":\" \","
    "\"item_id\":\"a8a2353c40a14803efa105c0531d353fd4b6882f\",\"location\":\" "
    "\",\"multiarch\":\"foreign\",\"name\":\"libmagic-mgc\",\"priority\":\"optional\","
    "\"scan_time\":\"2023/09/13 14:01:34\",\"size\":7128,\"source\":\"file\",\"vendor\":\"Ubuntu Developers "
    "<ubuntu-devel-discuss@lists.ubuntu.com>\","
    "\"version\":\"1:5.41-3ubuntu0.1\"},\"operation\":\"INSERTED\",\"type\":\"dbsync_packages\"}"};

const std::string invalidMsgStr {
    "random_string_:{\"data\":{\"architecture\":\"amd64\",\"checksum\":\"f2cacd7658244c009fc10aef49044865c24a7aff\","
    "\"description\":\"File type determination library using \\\"magic\\\" numbers (compiled magic "
    "file)\",\"format\":\"deb\",\"groups\":\"libs\",\"install_time\":\" \","
    "\"item_id\":\"a8a2353c40a14803efa105c0531d353fd4b6882f\",\"location\":\" "
    "\",\"multiarch\":\"foreign\",\"priority\":\"optional\","
    "\"scan_time\":\"2023/09/13 14:01:34\",\"size\":7128,\"source\":\"file\",\"vendor\":\"Ubuntu Developers "
    "<ubuntu-devel-discuss@lists.ubuntu.com>\","
    "\"version\":\"1:5.41-3ubuntu0.1\"},\"operation\":\"INSERTED\",\"type\":\"dbsync_packages\"}"};

std::vector<char> message(msgStr.begin(), msgStr.end());
std::vector<char> invalidMessage(invalidMsgStr.begin(), invalidMsgStr.end());

void DatabaseFeedManagerTests::SetUp()
{
    std::filesystem::create_directories(DESCRIPTION_DATABASE_DIR);

    std::string schemaStr;
    nlohmann::json jsonExample = nlohmann::json::parse(vulnerabilityCandidateExample);
    bool valid = flatbuffers::LoadFile(flatbufferSchema.c_str(), false, &schemaStr);
    assert(valid == true);
    assert(!jsonExample.empty());

    flatbuffers::Parser parser;
    valid = parser.Parse(schemaStr.c_str());
    assert(valid == true);

    Utils::RocksDBWrapper rocksDBWrapper(ROCKS_DB_PATH);

    for (const auto& item : jsonExample)
    {
        valid = parser.Parse(item.dump().c_str());
        assert(valid == true);

        uint8_t* buf = parser.builder_.GetBufferPointer();
        const size_t flatbufferSize = parser.builder_.GetSize();

        const rocksdb::Slice vulnerabilityCandidate(reinterpret_cast<const char*>(buf), flatbufferSize);
        rocksDBWrapper.put(packageName + "_" + item.at("cveId").get<std::string>(), vulnerabilityCandidate);
    }
}

void DatabaseFeedManagerTests::TearDown()
{
    spIndexerConnectorMock.reset();
    spPolicyManagerMock.reset();
    spContentRegisterMock.reset();
    spRouterSubscriberMock.reset();
    std::filesystem::remove_all(DESCRIPTION_DATABASE_DIR);
    std::filesystem::remove_all(ROCKS_DB_PATH);
}

TEST_F(DatabaseFeedManagerTests, GetVulnerabilityCandidatesSuccess)
{
    ScanContext context;
    context.build(message);

    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;

    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    spRouterSubscriberMock = std::make_shared<MockRouterSubscriber>(
        configurationParameters.at("topicName").get<const std::string>(), "vulnerability_feed_manager");
    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters);

    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));

    EXPECT_CALL(*spRouterSubscriberMock, subscribe(_));

    auto pIndexerConnectorTrap = std::make_shared<TrampolineIndexerConnector>();

    auto pDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineIndexerConnector,
                                              TrampolinePolicyManager,
                                              TrampolineContentRegister,
                                              TrampolineRouterSubscriber>>(pIndexerConnectorTrap)};

    std::vector<std::vector<uint8_t>> vulnerabilities;

    pDatabaseFeedManager->getVulnerabilitiesCandidates(
        "cnaName",
        context,
        [&vulnerabilities](const char* data, const size_t size) -> bool
        {
            bool valid = false;
            uint8_t ret[size];
            std::memcpy(ret, data, size);
            flatbuffers::Verifier verifier(ret, size);
            if (NSVulnerabilityScanner::VerifyScanVulnerabilityCandidateBuffer(verifier))
            {
                valid = true;
                vulnerabilities.push_back(std::vector<uint8_t>(ret, ret + size));
            }

            return valid;
        });

    flatbuffers::Verifier verifier1(vulnerabilities[0].data(), vulnerabilities[0].size());
    if (NSVulnerabilityScanner::VerifyScanVulnerabilityCandidateBuffer(verifier1))
    {
        const NSVulnerabilityScanner::ScanVulnerabilityCandidate* fb =
            NSVulnerabilityScanner::GetScanVulnerabilityCandidate(vulnerabilities[0].data());
        EXPECT_EQ(fb->cveId()->str(), "CVE-1999-1234");
    }

    flatbuffers::Verifier verifier2(vulnerabilities[1].data(), vulnerabilities[1].size());
    if (NSVulnerabilityScanner::VerifyScanVulnerabilityCandidateBuffer(verifier2))
    {
        const NSVulnerabilityScanner::ScanVulnerabilityCandidate* fb =
            NSVulnerabilityScanner::GetScanVulnerabilityCandidate(vulnerabilities[1].data());
        EXPECT_EQ(fb->cveId()->str(), "CVE-1999-1235");
    }
}

TEST_F(DatabaseFeedManagerTests, GetVulnerabilityCandidatesContextEmpty)
{
    ScanContext context;

    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;

    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    spRouterSubscriberMock = std::make_shared<MockRouterSubscriber>(
        configurationParameters.at("topicName").get<const std::string>(), "vulnerability_feed_manager");
    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters);

    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));

    EXPECT_CALL(*spRouterSubscriberMock, subscribe(_));

    auto pIndexerConnectorTrap = std::make_shared<TrampolineIndexerConnector>();

    auto pDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineIndexerConnector,
                                              TrampolinePolicyManager,
                                              TrampolineContentRegister,
                                              TrampolineRouterSubscriber>>(pIndexerConnectorTrap)};

    std::vector<std::vector<uint8_t>> vulnerabilities;

    pDatabaseFeedManager->getVulnerabilitiesCandidates(
        "cnaName",
        context,
        [&vulnerabilities](const char* data, const size_t size) -> bool
        {
            bool valid = false;
            uint8_t ret[size];
            std::memcpy(ret, data, size);
            flatbuffers::Verifier verifier(ret, size);
            if (NSVulnerabilityScanner::VerifyScanVulnerabilityCandidateBuffer(verifier))
            {
                valid = true;
                vulnerabilities.push_back(std::vector<uint8_t>(ret, ret + size));
            }

            return valid;
        });

    EXPECT_EQ(vulnerabilities.empty(), true);
}

TEST_F(DatabaseFeedManagerTests, GetVulnerabilityCandidatesNoPackageName)
{
    ScanContext context;
    context.build(invalidMessage);

    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;

    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    spRouterSubscriberMock = std::make_shared<MockRouterSubscriber>(
        configurationParameters.at("topicName").get<const std::string>(), "vulnerability_feed_manager");
    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters);

    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));

    EXPECT_CALL(*spRouterSubscriberMock, subscribe(_));

    auto pIndexerConnectorTrap = std::make_shared<TrampolineIndexerConnector>();

    auto pDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineIndexerConnector,
                                              TrampolinePolicyManager,
                                              TrampolineContentRegister,
                                              TrampolineRouterSubscriber>>(pIndexerConnectorTrap)};

    std::vector<std::vector<uint8_t>> vulnerabilities;

    pDatabaseFeedManager->getVulnerabilitiesCandidates(
        "cnaName",
        context,
        [&vulnerabilities](const char* data, const size_t size) -> bool
        {
            bool valid = false;
            uint8_t ret[size];
            std::memcpy(ret, data, size);
            flatbuffers::Verifier verifier(ret, size);
            if (NSVulnerabilityScanner::VerifyScanVulnerabilityCandidateBuffer(verifier))
            {
                valid = true;
                vulnerabilities.push_back(std::vector<uint8_t>(ret, ret + size));
            }

            return valid;
        });

    EXPECT_EQ(vulnerabilities.empty(), true);
}
