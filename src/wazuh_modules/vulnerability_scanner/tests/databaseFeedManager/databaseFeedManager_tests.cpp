/*
 * Wazuh Vulnerability scanner
 * Copyright (C) 2015, Wazuh Inc.
 * September 19, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "databaseFeedManager_tests.hpp"
#include <unordered_map>
#include "mockContentRegister.hpp"
#include "mockIndexerConnector.hpp"
#include "mockPolicyManager.hpp"
#include "mockRouterSubscriber.hpp"
#include "databaseFeedManager_traps.hpp"

std::shared_ptr<IndexerConnectorMock> pIndexerConnectorMock;
std::shared_ptr<PolicyManagerMock> pPolicyManagerMock;
std::shared_ptr<ContentRegisterMock> pContentRegisterMock;
std::shared_ptr<RouterSubscriberMock> pRouterSubscriberMock;

const std::string msgStr {
    "random_string_:{\"data\":{\"architecture\":\"amd64\",\"checksum\":\"f2cacd7658244c009fc10aef49044865c24a7aff\","
    "\"description\":\"File type determination library using \\\"magic\\\" numbers (compiled magic "
    "file)\",\"format\":\"deb\",\"groups\":\"libs\",\"install_time\":\" \","
    "\"item_id\":\"a8a2353c40a14803efa105c0531d353fd4b6882f\",\"location\":\" "
    "\",\"multiarch\":\"foreign\",\"name\":\"libmagic-mgc\",\"priority\":\"optional\","
    "\"scan_time\":\"2023/09/13 14:01:34\",\"size\":7128,\"source\":\"file\",\"vendor\":\"Ubuntu Developers "
    "<ubuntu-devel-discuss@lists.ubuntu.com>\","
    "\"version\":\"1:5.41-3ubuntu0.1\"},\"operation\":\"INSERTED\",\"type\":\"dbsync_packages\"}"};

std::vector<char> message(msgStr.begin(), msgStr.end());

TEST_F(DatabaseFeedManagerTests, ParsingInfo)
{
    ScanContext context;
    context.build(message);

    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;

    pIndexerConnectorMock = std::make_shared<IndexerConnectorMock>();
    pPolicyManagerMock = std::make_shared<PolicyManagerMock>();
    pRouterSubscriberMock = std::make_shared<RouterSubscriberMock>(
        configurationParameters.at("topicName").get<const std::string>(), "vulnerability_feed_manager");
    pContentRegisterMock = std::make_shared<ContentRegisterMock>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters);

    EXPECT_CALL(*pPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(testing::Return(configurationParameters));

    auto pIndexerConnectorTrap = std::make_shared<IndexerConnectorTrap>();

    auto pDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<IndexerConnectorTrap,
                                                      PolicyManagerTrap,
                                                      ContentRegisterTrap,
                                                      RouterSubscriberTrap>>(pIndexerConnectorTrap)};

    std::vector<std::vector<uint8_t>> vulnerabilities;

    pDatabaseFeedManager->getVulnerabilitiesCandidates(
        "cnaName",
        context,
        [&vulnerabilities](const char* data, const size_t size) -> bool
        {
            bool valid = false;
            uint8_t ret[size];
            std::memcpy(ret, data, size);
            flatbuffers::Verifier verifier(ret, size);
            if (NSVulnerabilityScanner::VerifyScanVulnerabilityCandidateBuffer(verifier))
            {
                valid = true;
                vulnerabilities.push_back(std::vector<uint8_t>(ret, ret + size));
            }

            return valid;
        });

    flatbuffers::Verifier verifier1(vulnerabilities[0].data(), vulnerabilities[0].size());
    if (NSVulnerabilityScanner::VerifyScanVulnerabilityCandidateBuffer(verifier1))
    {
        const NSVulnerabilityScanner::ScanVulnerabilityCandidate* fb =
            NSVulnerabilityScanner::GetScanVulnerabilityCandidate(vulnerabilities[0].data());
        EXPECT_EQ(fb->cveId()->str(), "CVE-1999-1234");
    }

    flatbuffers::Verifier verifier2(vulnerabilities[1].data(), vulnerabilities[1].size());
    if (NSVulnerabilityScanner::VerifyScanVulnerabilityCandidateBuffer(verifier2))
    {
        const NSVulnerabilityScanner::ScanVulnerabilityCandidate* fb =
            NSVulnerabilityScanner::GetScanVulnerabilityCandidate(vulnerabilities[1].data());
        EXPECT_EQ(fb->cveId()->str(), "CVE-1999-1235");
    }
}
