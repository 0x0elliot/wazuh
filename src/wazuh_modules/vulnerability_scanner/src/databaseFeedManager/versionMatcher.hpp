/*
 * Wazuh Vulnerability scanner - Database Feed Manager
 * Copyright (C) 2015, Wazuh Inc.
 * October 31, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _VERSION_MATCHER_HPP
#define _VERSION_MATCHER_HPP

#include <iostream>
#include <memory>
#include <regex>
#include <string>

enum class VersionObjectType : int
{
    Unspecified = 0,
    CalVer = 1,
    PEP440 = 2,
    MajorMinor = 3,
    SemVer = 4
};

/**
 * @brief IVersionObject class.
 *
 */
class IVersionObject
{
public:
    // LCOV_EXCL_START
    virtual ~IVersionObject() = default;
    // LCOV_EXCL_STOP

    /**
     * @brief Returns the VersionObjectType of the concrete class.
     *
     * @return VersionObjectType.
     */
    virtual VersionObjectType getType() = 0;

    /**
     * @brief Comparison operator ==.
     *
     * @param b comparison rhs object.
     * @return true/false according to equality condition.
     */
    virtual bool operator==(const IVersionObject& b) const = 0;

    /**
     * @brief Comparison operator <.
     *
     * @param b comparison rhs object.
     * @return true/false according to less than condition.
     */
    virtual bool operator<(const IVersionObject& b) const = 0;
};

/**
 * @brief VersionObjectCalVer class.
 *
 */
class VersionObjectCalVer final : public IVersionObject
{
private:
    static std::regex parserRegex;
    uint16_t year;
    uint8_t month;
    uint8_t day;
    uint32_t micro;

public:
    /**
     * @brief Constructor.
     *
     * @param version version string to create object from.
     */
    VersionObjectCalVer(const std::string version)
    {
        std::smatch parserMatches;
        if ((std::regex_match(version, parserMatches, parserRegex) == false) || (parserMatches.size() != 5))
        {
            throw std::runtime_error {"Error creating " + std::string(typeid(*this).name())};
        }

        if (parserMatches.str(1).size() == 2)
        {
            year = static_cast<uint16_t>(std::stoul(parserMatches.str(1))) + 2000;
        }
        else
        {
            year = static_cast<uint16_t>(std::stoul(parserMatches.str(1)));
        }
        if (parserMatches.str(2).size())
        {
            month = static_cast<uint8_t>(std::stoul(parserMatches.str(2).substr(1)));
            if (month < 1 || month > 12)
            {
                throw std::runtime_error {"Error creating " + std::string(typeid(*this).name())};
            }
        }
        else
        {
            month = 0;
        }
        if (parserMatches.str(3).size())
        {
            day = static_cast<uint8_t>(std::stoul(parserMatches.str(3).substr(1)));
            if (day < 1 || day > 31)
            {
                throw std::runtime_error {"Error creating " + std::string(typeid(*this).name())};
            }
        }
        else
        {
            day = 0;
        }
        if (parserMatches.str(4).size())
        {
            micro = static_cast<uint32_t>(std::stoul(parserMatches.str(4).substr(1)));
        }
        else
        {
            micro = 0;
        }
    }

    virtual ~VersionObjectCalVer() = default;

    /**
     * @brief Returns the VersionObjectType of this class.
     *
     * @return VersionObjectType.
     */
    VersionObjectType getType()
    {
        return VersionObjectType::CalVer;
    }

    /**
     * @brief Comparison operator ==.
     *
     * @param b comparison rhs object.
     * @return true/false according to equality condition.
     */
    bool operator==(const IVersionObject& b) const
    {
        const VersionObjectCalVer* pB = dynamic_cast<const VersionObjectCalVer*>(&b);
        if (pB == nullptr)
        {
            throw std::runtime_error {"Error casting VersionObject type"};
        }
        return (year == pB->year && month == pB->month && day == pB->day && micro == pB->micro);
    }

    /**
     * @brief Comparison operator <.
     *
     * @param b comparison rhs object.
     * @return true/false according to less than condition.
     */
    bool operator<(const IVersionObject& b) const
    {
        const VersionObjectCalVer* pB = dynamic_cast<const VersionObjectCalVer*>(&b);
        if (pB == nullptr)
        {
            throw std::runtime_error {"Error casting VersionObject type"};
        }
        if (year < pB->year)
        {
            return true;
        }
        else if (year == pB->year)
        {
            if (month < pB->month)
            {
                return true;
            }
            else if (month == pB->month)
            {
                if (day < pB->day)
                {
                    return true;
                }
                else if (day == pB->day)
                {
                    if (micro < pB->micro)
                    {
                        return true;
                    }
                }
            }
        }
        return false;
    }
};

/**
 * @brief VersionObjectPEP440 class.
 *
 */
class VersionObjectPEP440 final : public IVersionObject
{
private:
    static std::regex parserRegex;
    static std::regex parserVersionStrRegex;
    uint32_t epoch;
    std::string versionStr;
    std::string preReleaseStr;
    uint32_t preReleaseNumber;
    uint32_t postReleaseNumber;
    uint32_t devReleaseNumber;
    bool hasPreRelease;
    bool hasPostRelease;
    bool hasDevRelease;

    /**
     * @brief Comparison method for the versionStr variable members.
     *
     * @param versionStrA versionStr member of object A.
     * @param versionStrB versionStr member of object B.
     * @return 0  if A is equal to B.
     *         -1 if A is less than B.
     *         1  if A is greater than B.
     */
    static int compareVersionStr(const std::string& versionStrA, const std::string& versionStrB) const
    {
        std::deque<uint32_t> versionStrSplitA;
        std::sregex_token_iterator itA(versionStrA.begin(), versionStrA.end(), parserVersionStrRegex, -1);
        std::sregex_token_iterator itEndA;
        while (itA != itEndA)
        {
            versionStrSplitA.push_back(static_cast<uint32_t>(std::stoul(itA->str())));
            itA++;
        }

        std::deque<uint32_t> versionStrSplitB;
        std::sregex_token_iterator itB(versionStrB.begin(), versionStrB.end(), parserVersionStrRegex, -1);
        std::sregex_token_iterator itEndB;
        while (itB != itEndB)
        {
            versionStrSplitB.push_back(static_cast<uint32_t>(std::stoul(itB->str())));
            itB++;
        }

        while (versionStrSplitA.size() < versionStrSplitB.size())
        {
            versionStrSplitA.push_back(0);
        }

        while (versionStrSplitB.size() < versionStrSplitA.size())
        {
            versionStrSplitB.push_back(0);
        }

        for (size_t itemIdx = 0; itemIdx < versionStrSplitA.size(); itemIdx++)
        {
            if (versionStrSplitA[itemIdx] < versionStrSplitB[itemIdx])
            {
                return -1;
            }
            if (versionStrSplitA[itemIdx] > versionStrSplitB[itemIdx])
            {
                return 1;
            }
        }

        return 0;
    }

public:
    /**
     * @brief Constructor.
     *
     * @param version version string to create object from.
     */
    VersionObjectPEP440(const std::string& version)
    {
        std::smatch parserMatches;
        if ((std::regex_match(version, parserMatches, parserRegex) == false) || (parserMatches.size() != 7))
        {
            throw std::runtime_error {"Error creating " + std::string(typeid(*this).name())};
        }

        if (parserMatches.str(1).size())
        {
            epoch = static_cast<uint32_t>(std::stoul(parserMatches.str(1)));
        }
        else
        {
            epoch = 0;
        }

        versionStr = parserMatches.str(2);

        if (parserMatches.str(3).size() && parserMatches.str(4).size())
        {
            preReleaseStr = parserMatches.str(3);
            preReleaseNumber = static_cast<uint32_t>(std::stoul(parserMatches.str(4)));
            hasPreRelease = true;
        }
        else
        {
            preReleaseNumber = 0;
            hasPreRelease = false;
        }

        if (parserMatches.str(5).size())
        {
            postReleaseNumber = static_cast<uint32_t>(std::stoul(parserMatches.str(5)));
            hasPostRelease = true;
        }
        else
        {
            postReleaseNumber = 0;
            hasPostRelease = false;
        }

        if (parserMatches.str(6).size())
        {
            devReleaseNumber = static_cast<uint32_t>(std::stoul(parserMatches.str(6)));
            hasDevRelease = true;
        }
        else
        {
            devReleaseNumber = 0;
            hasDevRelease = false;
        }
    }

    virtual ~VersionObjectPEP440() = default;

    /**
     * @brief Returns the VersionObjectType of this class.
     *
     * @return VersionObjectType.
     */
    VersionObjectType getType()
    {
        return VersionObjectType::PEP440;
    }

    /**
     * @brief Comparison operator ==.
     *
     * @param b comparison rhs object.
     * @return true/false according to equality condition.
     */
    bool operator==(const IVersionObject& b) const
    {
        const VersionObjectPEP440* pB = dynamic_cast<const VersionObjectPEP440*>(&b);
        if (pB == nullptr)
        {
            throw std::runtime_error {"Error casting VersionObject type"};
        }
        return (epoch == pB->epoch && !compareVersionStr(versionStr, pB->versionStr) &&
                preReleaseStr == pB->preReleaseStr && preReleaseNumber == pB->preReleaseNumber &&
                postReleaseNumber == pB->postReleaseNumber && devReleaseNumber == pB->devReleaseNumber &&
                hasPreRelease == pB->hasPreRelease && hasPostRelease == pB->hasPostRelease &&
                hasDevRelease == pB->hasDevRelease);
    }

    /**
     * @brief Comparison operator <.
     *
     * @param b comparison rhs object.
     * @return true/false according to less than condition.
     */
    bool operator<(const IVersionObject& b) const
    {
        const VersionObjectPEP440* pB = dynamic_cast<const VersionObjectPEP440*>(&b);
        if (pB == nullptr)
        {
            throw std::runtime_error {"Error casting VersionObject type"};
        }
        if (epoch < pB->epoch)
        {
            return true;
        }
        else if (epoch == pB->epoch)
        {
            int resultVersionStr = compareVersionStr(versionStr, pB->versionStr);
            if (resultVersionStr < 0)
            {
                return true;
            }
            else if (!resultVersionStr)
            {
                if (hasPreRelease && pB->hasPreRelease == false)
                {
                    return true;
                }
                else if (hasPreRelease == false && pB->hasPreRelease)
                {
                    return false;
                }
                else if (hasPreRelease && pB->hasPreRelease)
                {
                    int resultPreReleaseStr = preReleaseStr.compare(pB->preReleaseStr);
                    if (resultPreReleaseStr < 0)
                    {
                        return true;
                    }
                    else if (resultPreReleaseStr > 0)
                    {
                        return false;
                    }
                    else if (!resultPreReleaseStr)
                    {
                        if (preReleaseNumber < pB->preReleaseNumber)
                        {
                            return true;
                        }
                        else if (preReleaseNumber > pB->preReleaseNumber)
                        {
                            return false;
                        }
                    }
                }

                if (hasPostRelease && pB->hasPostRelease == false)
                {
                    return false;
                }
                else if (hasPostRelease == false && pB->hasPostRelease)
                {
                    return true;
                }
                else if (hasPostRelease && pB->hasPostRelease)
                {
                    if (postReleaseNumber < pB->postReleaseNumber)
                    {
                        return true;
                    }
                    else if (postReleaseNumber > pB->postReleaseNumber)
                    {
                        return false;
                    }
                }

                if (hasDevRelease && pB->hasDevRelease == false)
                {
                    return false;
                }
                else if (hasDevRelease == false && pB->hasDevRelease)
                {
                    return true;
                }
                else if (hasDevRelease && pB->hasDevRelease)
                {
                    if (devReleaseNumber < pB->devReleaseNumber)
                    {
                        return true;
                    }
                    else if (devReleaseNumber > pB->devReleaseNumber)
                    {
                        return false;
                    }
                }
            }
        }
        return false;
    }
};

/**
 * @brief VersionObjectMajorMinor class.
 *
 */
class VersionObjectMajorMinor final : public IVersionObject
{
private:
    static std::regex parserRegex;
    uint32_t major;
    uint32_t minor;

public:
    /**
     * @brief Constructor.
     *
     * @param version version string to create object from.
     */
    VersionObjectMajorMinor(const std::string& version)
    {
        std::smatch parserMatches;
        if ((std::regex_match(version, parserMatches, parserRegex) == false) || (parserMatches.size() != 3))
        {
            throw std::runtime_error {"Error creating " + std::string(typeid(*this).name())};
        }
        major = static_cast<uint32_t>(std::stoul(parserMatches.str(1)));
        minor = static_cast<uint32_t>(std::stoul(parserMatches.str(2)));
    }

    virtual ~VersionObjectMajorMinor() = default;

    /**
     * @brief Returns the VersionObjectType of this class.
     *
     * @return VersionObjectType.
     */
    VersionObjectType getType()
    {
        return VersionObjectType::MajorMinor;
    }

    /**
     * @brief Comparison operator ==.
     *
     * @param b comparison rhs object.
     * @return true/false according to equality condition.
     */
    bool operator==(const IVersionObject& b) const
    {
        const VersionObjectMajorMinor* pB = dynamic_cast<const VersionObjectMajorMinor*>(&b);
        if (pB == nullptr)
        {
            throw std::runtime_error {"Error casting VersionObject type"};
        }
        return (major == pB->major && minor == pB->minor);
    }

    /**
     * @brief Comparison operator <.
     *
     * @param b comparison rhs object.
     * @return true/false according to less than condition.
     */
    bool operator<(const IVersionObject& b) const
    {
        const VersionObjectMajorMinor* pB = dynamic_cast<const VersionObjectMajorMinor*>(&b);
        if (pB == nullptr)
        {
            throw std::runtime_error {"Error casting VersionObject type"};
        }
        if (major < pB->major)
        {
            return true;
        }
        else if (major == pB->major)
        {
            if (minor < pB->minor)
            {
                return true;
            }
        }
        return false;
    }
};

/**
 * @brief VersionObjectSemVer class.
 *
 */
class VersionObjectSemVer final : public IVersionObject
{
private:
    static std::regex parserRegex;
    uint32_t major;
    uint32_t minor;
    uint32_t patch;
    std::string preRelease;
    std::string buildMetadata;

public:
    /**
     * @brief Constructor.
     *
     * @param version version string to create object from.
     */
    VersionObjectSemVer(const std::string& version)
    {
        std::smatch parserMatches;
        if ((std::regex_match(version, parserMatches, parserRegex) == false) || (parserMatches.size() != 6))
        {
            throw std::runtime_error {"Error creating " + std::string(typeid(*this).name())};
        }
        major = static_cast<uint32_t>(std::stoul(parserMatches.str(1)));
        minor = static_cast<uint32_t>(std::stoul(parserMatches.str(2)));
        patch = static_cast<uint32_t>(std::stoul(parserMatches.str(3)));
        if (parserMatches.str(4).size())
        {
            preRelease = parserMatches[4];
        }
        if (parserMatches.str(5).size())
        {
            buildMetadata = parserMatches[5];
        }
    }

    virtual ~VersionObjectSemVer() = default;

    /**
     * @brief Returns the VersionObjectType of this class.
     *
     * @return VersionObjectType.
     */
    VersionObjectType getType()
    {
        return VersionObjectType::SemVer;
    }

    /**
     * @brief Comparison operator ==.
     *
     * @param b comparison rhs object.
     * @return true/false according to equality condition.
     */
    bool operator==(const IVersionObject& b) const
    {
        const VersionObjectSemVer* pB = dynamic_cast<const VersionObjectSemVer*>(&b);
        if (pB == nullptr)
        {
            throw std::runtime_error {"Error casting VersionObject type"};
        }
        return (major == pB->major && minor == pB->minor && patch == pB->patch && preRelease == pB->preRelease);
    }

    /**
     * @brief Comparison operator <.
     *
     * @param b comparison rhs object.
     * @return true/false according to less than condition.
     */
    bool operator<(const IVersionObject& b) const
    {
        const VersionObjectSemVer* pB = dynamic_cast<const VersionObjectSemVer*>(&b);
        if (pB == nullptr)
        {
            throw std::runtime_error {"Error casting VersionObject type"};
        }
        if (major < pB->major)
        {
            return true;
        }
        else if (major == pB->major)
        {
            if (minor < pB->minor)
            {
                return true;
            }
            else if (minor == pB->minor)
            {
                if (patch < pB->patch)
                {
                    return true;
                }
                else if (patch == pB->patch)
                {
                    if (preRelease.size() && !pB->preRelease.size())
                    {
                        return true;
                    }
                    else if (preRelease.size() && pB->preRelease.size())
                    {
                        if (preRelease.compare(pB->preRelease) < 0)
                        {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
};

/**
 * @brief VersionMatcher class.
 *
 */
class VersionMatcher final
{
private:
    /**
     * @brief Inserts a translation entry in a rocksdb database.
     *
     * @param version string version item to create object from
     * @return std::shared_ptr<IVersionObject>
     */
    static std::shared_ptr<IVersionObject> createVersionObject(const std::string& version, VersionObjectType type)
    {
        switch (type)
        {
            default: throw std::runtime_error {"Error creating VersionObject. Invalid type"};

            case VersionObjectType::Unspecified:
                try
                {
                    return std::make_shared<VersionObjectCalVer>(version);
                }
                catch (const std::runtime_error& e)
                {
                    try
                    {
                        return std::make_shared<VersionObjectPEP440>(version);
                    }
                    catch (const std::runtime_error& e)
                    {
                        try
                        {
                            return std::make_shared<VersionObjectMajorMinor>(version);
                        }
                        catch (const std::runtime_error& e)
                        {
                            try
                            {
                                return std::make_shared<VersionObjectSemVer>(version);
                            }
                            catch (const std::runtime_error& e)
                            {
                                throw std::runtime_error {"Error creating VersionObject. Unrecognized type"};
                            }
                        }
                    }
                }

            case VersionObjectType::CalVer:
                try
                {
                    return std::make_shared<VersionObjectCalVer>(version);
                }
                catch (const std::runtime_error& e)
                {
                    throw std::runtime_error {
                        "Error creating VersionObject. Version string dont match the type specified"};
                }

            case VersionObjectType::PEP440:
                try
                {
                    return std::make_shared<VersionObjectPEP440>(version);
                }
                catch (const std::runtime_error& e)
                {
                    throw std::runtime_error {
                        "Error creating VersionObject. Version string dont match the type specified"};
                }

            case VersionObjectType::MajorMinor:
                try
                {
                    return std::make_shared<VersionObjectMajorMinor>(version);
                }
                catch (const std::runtime_error& e)
                {
                    throw std::runtime_error {
                        "Error creating VersionObject. Version string dont match the type specified"};
                }

            case VersionObjectType::SemVer:
                try
                {
                    return std::make_shared<VersionObjectSemVer>(version);
                }
                catch (const std::runtime_error& e)
                {
                    throw std::runtime_error {
                        "Error creating VersionObject. Version string dont match the type specified"};
                }
        }
    }

public:
    /**
     * @brief Inserts a translation entry in a rocksdb database.
     *
     * @param versionA string version item A to compare
     * @param versionB string version item B to compare
     * @param type VersionObjectType of the version strings A and B to compare.
     * @return int
     */
    static int compare(const std::string versionA,
                       const std::string versionB,
                       VersionObjectType type = VersionObjectType::Unspecified)
    {
        auto pVersionObjectA = createVersionObject(versionA, type);
        auto pVersionObjectB = createVersionObject(versionB, type);

        if (pVersionObjectA->getType() != pVersionObjectB->getType())
        {
            throw std::runtime_error {"Error comparing VersionObjects. VersionObjects types are not equal"};
        }

        if (*pVersionObjectA == *pVersionObjectB)
        {
            return 0;
        }
        else if (*pVersionObjectA < *pVersionObjectB)
        {
            return -1;
        }
        else
        {
            return 1;
        }
    }
};

#endif // _VERSION_MATCHER_HPP
