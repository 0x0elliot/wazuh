/*
 * Wazuh Vulnerability scanner - Database Feed Manager
 * Copyright (C) 2015, Wazuh Inc.
 * Oct 3, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _UPDATE_CVE_DESCRIPTION_HPP
#define _UPDATE_CVE_DESCRIPTION_HPP

#include "chainOfResponsability.hpp"
#include "cve5_generated.h"
#include "eventContext.hpp"
#include "flatbuffers/flatbuffers.h"
#include "rocksDBWrapper.hpp"
#include "vulnerabilityDescription_generated.h"

constexpr auto DESCRIPTION_DATABASE_PATH {"queue/vd/descriptions"};
constexpr auto CVE5_DATABASE_PATH {"queue/vd/cve5"};

/**
 * @brief UpdateCVEDescription class.
 *
 */
class UpdateCVEDescription final
{
public:
    /**
     * @brief Reads CVE5 database, creates a vulnerability description flatbuffer and stores it in a specific RocksDB
     * database.
     *
     * @param resource CVE ID.
     * @param cve5Flatbuffer CVE5 Flatbuffer.
     */
    static void storeVulnerabilityDescription(const std::string& resource, const cve_v5::Entry* cve5Flatbuffer)
    {
        auto metricsArray = cve5Flatbuffer->containers()->cna()->metrics();
        const size_t sizeM = (nullptr != metricsArray) ? metricsArray->size() : 0;
        auto descriptionArray = cve5Flatbuffer->containers()->cna()->descriptions();
        const size_t sizeD = (nullptr != descriptionArray) ? descriptionArray->size() : 0;
        auto referencesArray = cve5Flatbuffer->containers()->cna()->references();
        const size_t sizeR = (nullptr != referencesArray) ? referencesArray->size() : 0;
        size_t sizeT = (sizeM > sizeD) ? sizeM : sizeD;
        sizeT = (sizeT > sizeR) ? sizeT : sizeR;

        float VulnDescFBScoreBase = 0.0;
        std::string VulnDescFBClassificationStr;
        std::string VulnDescFBDescriptionStr;
        std::string VulnDescFBSeverityStr;
        std::string VulnDescFBScoreVersionStr;
        std::string VulnDescFBReferenceStr;

        bool cont = true;
        for (size_t i = 0; i < sizeT; ++i)
        {
            if (i < sizeM)
            {
                auto metric = metricsArray->Get(i);
                if (metric->cvssV3_1())
                {
                    VulnDescFBScoreBase = metric->cvssV3_1()->baseScore();
                    auto baseSeverity = metric->cvssV3_1()->baseSeverity();
                    VulnDescFBSeverityStr = (nullptr != baseSeverity) ? baseSeverity->str() : "";
                    auto version = metric->cvssV3_1()->version();
                    VulnDescFBScoreVersionStr = (nullptr != version) ? version->str() : "";
                    auto format = metric->format();
                    VulnDescFBClassificationStr = (nullptr != format) ? format->str() : "";
                }
            }
            if (i < sizeR)
            {
                auto reference = referencesArray->Get(i);
                if (reference->url())
                {
                    VulnDescFBReferenceStr = VulnDescFBReferenceStr + reference->url()->str() + ", ";
                }
            }
            if ((i < sizeD) && cont)
            {
                auto description = descriptionArray->Get(i);
                if (description->lang()->str().compare("en") == 0)
                {
                    VulnDescFBDescriptionStr = description->value()->str();
                    cont = false;
                }
            }
        }
        VulnDescFBReferenceStr = VulnDescFBReferenceStr.substr(0, VulnDescFBReferenceStr.size() - 2);

        flatbuffers::FlatBufferBuilder builder;

        auto VulnDescFBClassification {builder.CreateString(VulnDescFBClassificationStr)};
        auto VulnDescFBDescription {builder.CreateString(VulnDescFBDescriptionStr)};
        auto VulnDescFBSeverity {builder.CreateString(VulnDescFBSeverityStr)};
        auto VulnDescFBScoreVersion {builder.CreateString(VulnDescFBScoreVersionStr)};
        auto VulnDescFBReference {builder.CreateString(VulnDescFBReferenceStr)};

        NSVulnerabilityScanner::VulnerabilityDescriptionBuilder vulnerabilityDescriptionBuilder(builder);
        vulnerabilityDescriptionBuilder.add_scoreBase(VulnDescFBScoreBase);
        vulnerabilityDescriptionBuilder.add_classification(VulnDescFBClassification);
        vulnerabilityDescriptionBuilder.add_description(VulnDescFBDescription);
        vulnerabilityDescriptionBuilder.add_severity(VulnDescFBSeverity);
        vulnerabilityDescriptionBuilder.add_scoreVersion(VulnDescFBScoreVersion);
        vulnerabilityDescriptionBuilder.add_reference(VulnDescFBReference);

        auto vulnerabilityDescriptionFB = vulnerabilityDescriptionBuilder.Finish();
        builder.Finish(vulnerabilityDescriptionFB);

        const uint8_t* buffer = builder.GetBufferPointer();
        size_t flatbufferSize = builder.GetSize();

        try
        {
            Utils::RocksDBWrapper rocksDBWrapper(DESCRIPTION_DATABASE_PATH);

            const rocksdb::Slice VulnerabilityDescriptionSlice(reinterpret_cast<const char*>(buffer), flatbufferSize);
            rocksDBWrapper.put(resource, VulnerabilityDescriptionSlice);
        }
        catch (...)
        {
            std::cerr << "Couldn't save vulnerability description in database" << std::endl;
        }
    }
};

#endif // _UPDATE_CVE_DESCRIPTION_HPP
