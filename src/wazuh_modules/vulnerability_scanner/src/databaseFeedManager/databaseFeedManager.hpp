/*
 * Wazuh Vulnerability scanner
 * Copyright (C) 2015, Wazuh Inc.
 * March 25, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _DATABASE_FEED_MANAGER_HPP
#define _DATABASE_FEED_MANAGER_HPP

#include "../policyManager/policyManager.hpp"
#include "../scanOrchestrator/scanContext.hpp"
#include "cacheLRU.hpp"
#include "contentRegister.hpp"
#include "eventDecoder.hpp"
#include "feedIndexer.hpp"
#include "indexerConnector.hpp"
#include "observer.hpp"
#include "rocksDBWrapper.hpp"
#include "routerSubscriber.hpp"
#include "scanDispatcher.hpp"
#include "storeModel.hpp"
#include "vulnerabilityCandidate_generated.h"
#include "vulnerabilityDescription_generated.h"
#include "vulnerabilityRemediations_generated.h"
#include "vulnerabilityTranslationPackages_generated.h"
#include <external/nlohmann/json.hpp>
#include <functional>
#include <memory>
#include <string>
#include <vector>

constexpr auto DESCRIPTION_DATABASE_PATH {"queue/vd/descriptions"};
constexpr auto REMEDIATIONS_DATABASE_PATH {"queue/vd/remediations"};
constexpr auto TRANSLATIONS_DATABASE_PATH {"queue/vd/translations"};
constexpr auto CANDIDATES_DATABASE_PATH {"queue/vd/candidates"};

constexpr auto CACHE_SIZE {2048};

using namespace NSVulnerabilityScanner;

/**
 * @brief A struct for storing a pair of FlatBuffers data.
 *
 * The `FlatbufferDataPair` struct is designed to store a pair of related FlatBuffers data:
 * a `rocksdb::PinnableSlice` containing the serialized data and a pointer to the deserialized
 * data of type `FlatbufferType`. This allows for efficient storage and access to both the raw
 * serialized data and its parsed form.
 *
 * @tparam FlatbufferType The type of the FlatBuffers object that this struct represents.
 */
template<typename FlatbufferType>
struct FlatbufferDataPair
{
    /**
     * @brief A slice to the serialized FlatBuffers data.
     *
     * The `slice` member stores a `rocksdb::PinnableSlice` that contains the serialized
     * FlatBuffers data.
     */
    rocksdb::PinnableSlice slice;

    /**
     * @brief A pointer to the deserialized FlatBuffers data.
     *
     * The `data` member is a pointer to the deserialized FlatBuffers data of type `FlatbufferType`.
     * It provides direct access to the parsed information.
     */
    const FlatbufferType* data;
};

/**
 * @brief DatabaseFeedManager class.
 *
 * @tparam TIndexerConnector Indexer connector type.
 * @tparam TPolicyManager Policy manager type.
 * @tparam TContentRegister Content register type.
 * @tparam TRouterSubscriber Router subscriber type.
 */
template<typename TIndexerConnector = IndexerConnector,
         typename TPolicyManager = PolicyManager,
         typename TContentRegister = ContentRegister,
         typename TRouterSubscriber = RouterSubscriber>
class TDatabaseFeedManager final : public Observer<nlohmann::json&>
{
public:
    /**
     * @brief Class constructor.
     *
     * @param indexerConnector Indexer connector.
     */
    // TODO: Remove LCOV flags once the implementation of the 'Indexer Connector' module is completed
    // LCOV_EXCL_START
    explicit TDatabaseFeedManager(std::shared_ptr<TIndexerConnector> indexerConnector)
        : Observer("database_feed_manager")
        , m_indexerConnector(indexerConnector)
    {

        const auto updaterPolicy = TPolicyManager::instance().getUpdaterConfiguration();
        // Vulnerability content updater initialization.
        m_contentRegistration = std::make_unique<TContentRegister>(
            updaterPolicy.at("topicName"), TPolicyManager::instance().getUpdaterConfiguration());

        m_descriptionsDatabase = std::make_unique<Utils::RocksDBWrapper>(DESCRIPTION_DATABASE_PATH);
        m_remediationsDatabase = std::make_unique<Utils::RocksDBWrapper>(REMEDIATIONS_DATABASE_PATH);
        m_translationsDatabase = std::make_unique<Utils::RocksDBWrapper>(TRANSLATIONS_DATABASE_PATH);

        m_translationsCache = std::make_unique<LRUCache<std::string, std::string>>(CACHE_SIZE);

        // Subscription to vulnerability detector content update events.
        m_contentUpdateSubscription =
            std::make_unique<TRouterSubscriber>(updaterPolicy.at("topicName"), "vulnerability_feed_manager");

        m_contentUpdateSubscription->subscribe(
            [this](const std::vector<char>& message)
            {
                std::cout << "DatabaseFeedManager::update" << std::endl;
                auto eventContext = std::make_shared<EventContext>(EventContext {.message = message});
                auto eventDecoder = std::make_shared<EventDecoder>();
                eventDecoder->setLast(std::make_shared<StoreModel>());
                eventDecoder->setLast(std::make_shared<FeedIndexer<TIndexerConnector>>(m_indexerConnector));
                eventDecoder->setLast(std::make_shared<ScanDispatcher>());

                eventDecoder->handleRequest(eventContext);
            });
    }

    /**
     * @brief Retrieves vulnerability remediation information from the database.
     *
     * This function retrieves remediation information associated with a given CVE ID
     * from the underlying databnd storase aes it in the provided `dtoVulnRemediation`
     * object.
     *
     * @param cveId The CVE ID for which remediation information is requested.
     * @param dtoVulnRemediation A reference to a `FlatbufferDataPair` object
     *        where the retrieved remediation information will be stored.
     *
     * @throws std::runtime_error if the value for the specified `cveId` does not exist
     *         in the database.
     * @throws std::runtime_error if the retrieved data from the database is invalid or
     *         not in the expected FlatBuffers format.
     */
    void getVulnerabilityRemediation(std::string_view cveId, FlatbufferDataPair<RemediationInfo>& dtoVulnRemediation)
    {
        std::string key_str {cveId};

        auto result = m_remediationsDatabase->get(key_str, dtoVulnRemediation.slice);

        if (!result)
        {
            throw std::runtime_error("Value for key " + key_str + " does not exist in database.");
        }

        flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(dtoVulnRemediation.slice.data()),
                                       dtoVulnRemediation.slice.size());
        if (!VerifyRemediationInfoBuffer(verifier))
        {
            throw std::runtime_error("Error: Invalid FlatBuffers data in RocksDB.");
        }

        dtoVulnRemediation.data = GetRemediationInfo(reinterpret_cast<const uint8_t*>(dtoVulnRemediation.slice.data()));
    }

    /**
     * @brief Retrieves vulnerability package translation information from the database.
     *
     * This function retrieves package translation information associated with a given name ID
     * from the underlying database and stores it in the provided `dtoVulnTranslation`
     * object.
     *
     * This function uses a cache memory to optimize the operations.
     *
     * @param packageName The name ID for which package translation is requested.
     * @param dtoVulnTranslation A reference to a `FlatbufferDataPair` object
     *        where the retrieved remediation information will be stored.
     *
     * @throws std::runtime_error if the value for the specified `cveId` does not exist
     *         in the database.
     * @throws std::runtime_error if the retrieved data from the database is invalid or
     *         not in the expected FlatBuffers format.
     */
    void getWazuhPackageTranslation(const std::string& packageName,
                                    const std::function<void(const NSVulnerabilityScanner::srcTrlData&)>& callback)
    {
        auto resultCache = m_translationsCache->getValue(packageName);

        if (resultCache.has_value())
        {
            std::cerr << "Cache hit for package '" << packageName << "'\n";

            FlatbufferDataPair<PackageTranslation> dtoVulnTranslation;

            auto resultQuery = m_translationsDatabase->get(resultCache.value(), dtoVulnTranslation.slice);
            if (!resultQuery)
            {
                throw std::runtime_error("Value for key " + resultCache.value() + " does not exist in database.");
            }

            flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(dtoVulnTranslation.slice.data()),
                                           dtoVulnTranslation.slice.size());
            if (!VerifyPackageTranslationBuffer(verifier))
            {
                throw std::runtime_error("Error: Invalid FlatBuffers data in RocksDB.");
            }

            dtoVulnTranslation.data =
                GetPackageTranslation(reinterpret_cast<const uint8_t*>(dtoVulnTranslation.slice.data()));

            auto translations = dtoVulnTranslation.data->data()->translations();
            for (unsigned int index = 0; index < translations->size(); index++)
            {
                callback(*(translations->Get(index)));
            }

            return;
        }

        std::cerr << "Cache miss for package '" << packageName << "'\n";
        for (const auto& [key, value] : m_translationsDatabase->begin())
        {
            auto queryData = GetPackageTranslation(reinterpret_cast<const uint8_t*>(value.data()));
            std::regex product_pattern {queryData->data()->source()->product()->str()};
            if (std::regex_match(packageName, product_pattern))
            {
                flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(value.data()), value.size());
                if (!VerifyPackageTranslationBuffer(verifier))
                {
                    throw std::runtime_error("Error: Invalid FlatBuffers data in RocksDB.");
                }

                auto translations = queryData->data()->translations();
                for (unsigned int index = 0; index < translations->size(); index++)
                {
                    callback(*(translations->Get(index)));
                }

                m_translationsCache->insertKey(packageName, queryData->translation_id()->str());
                return;
            }
        }
        std::cerr << "No translation available for package '" << packageName << "'\n";
    }

    /**
     * @brief Get the Vulnerabilities Candidates information.
     *
     * @param cnaName RocksDB table identifier.
     * @param context Scan context structure.
     * @param callback Store vulnerability data.
     */
    void getVulnerabilitiesCandidates(const std::string& cnaName,
                                      const ScanContext& context,
                                      const std::function<bool(const char* data, const size_t size)>& callback)
    {
        std::string packageName;
        std::string rocksDBKey;

        // TODO: Process cnaName to get the required database path, now harcoded in CANDIDATES_DATABASE_PATH

        try
        {
            Utils::RocksDBWrapper rocksDBWrapper(CANDIDATES_DATABASE_PATH);
            if (!context.contextData.empty())
            {
                try
                {
                    packageName = context.contextData.at("data").at("name");
                    for (const auto& [key, value] : rocksDBWrapper.seek(packageName))
                    {
                        if (callback(reinterpret_cast<const char*>(value.data()), value.size()))
                        {
                            // Logging
                        }
                    }
                }
                catch (...)
                {
                    // Loggin
                    std::cerr << "Invalid package\n";
                }
            }
        }
        catch (...)
        {
            // Loggin
            std::cerr << "Unable to open database\n";
        }
    }

    /**
     * @brief Updates scheduler interval.
     *
     * @param data Data containing the interval.
     */
    void update(nlohmann::json& data) override
    {
        m_contentRegistration->changeSchedulerInterval(data.at("updater").at("interval").get<size_t>());
    }
    // LCOV_EXCL_STOP

    /**
     * @brief Gets descriptive information for a cveid.
     *
     * @param cveId cveid to search.
     * @param resultContainer container struct to store the result.
     */
    void getVulnerabiltyDescriptiveInformation(const std::string_view cveId,
                                               FlatbufferDataPair<VulnerabilityDescription>& resultContainer)
    {
        if (m_descriptionsDatabase->get(std::string(cveId), resultContainer.slice) == false)
        {
            throw std::runtime_error(
                "Error getting VulnerabilityDescription object from rocksdb. Object not found for cveId: " +
                std::string(cveId));
        }

        flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(resultContainer.slice.data()),
                                       resultContainer.slice.size());
        if (NSVulnerabilityScanner::VerifyVulnerabilityDescriptionBuffer(verifier) == false)
        {
            throw std::runtime_error(
                "Error getting VulnerabilityDescription object from rocksdb. FlatBuffers verifier failed");
        }

        resultContainer.data = const_cast<NSVulnerabilityScanner::VulnerabilityDescription*>(
            NSVulnerabilityScanner::GetVulnerabilityDescription(resultContainer.slice.data()));
    }

private:
    std::unique_ptr<TRouterSubscriber> m_contentUpdateSubscription;
    std::unique_ptr<TContentRegister> m_contentRegistration;
    std::shared_ptr<TIndexerConnector> m_indexerConnector;
    std::unique_ptr<Utils::RocksDBWrapper> m_descriptionsDatabase;
    std::unique_ptr<Utils::RocksDBWrapper> m_remediationsDatabase;
    std::unique_ptr<Utils::RocksDBWrapper> m_translationsDatabase;
    std::unique_ptr<LRUCache<std::string, std::string>> m_translationsCache;
    std::map<std::string, std::unique_ptr<Utils::RocksDBWrapper>> m_feedsDatabases;
};

using DatabaseFeedManager = TDatabaseFeedManager<>;

#endif // _DATABASE_FEED_MANAGER_HPP
