/*
 * Wazuh Vulnerability scanner
 * Copyright (C) 2015, Wazuh Inc.
 * March 25, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _DATABASE_FEED_MANAGER_HPP
#define _DATABASE_FEED_MANAGER_HPP

#include "../include/scanVulnerabilityCandidate_generated.h"
#include "../policyManager/policyManager.hpp"
#include "../scanOrchestrator/scanContext.hpp"
#include "contentRegister.hpp"
#include "eventDecoder.hpp"
#include "feedIndexer.hpp"
#include "indexerConnector.hpp"
#include "observer.hpp"
#include "rocksDBWrapper.hpp"
#include "routerSubscriber.hpp"
#include "scanDispatcher.hpp"
#include "storeModel.hpp"
#include "vulnerabilityDescription_generated.h"
#include <external/nlohmann/json.hpp>
#include <functional>
#include <memory>
#include <string>
#include <vector>

constexpr auto DESCRIPTION_DATABASE_PATH {"queue/vd/descriptions"};
constexpr auto REMEDIATIONS_DATABASE_PATH {"queue/vd/remediations"};
constexpr auto ROCKS_DB_PATH {"queue/vd/candidates"};

/**
 * @brief A struct for storing a pair of FlatBuffers data.
 *
 * The `FlatbufferDataPair` struct is designed to store a pair of related FlatBuffers data:
 * a `rocksdb::PinnableSlice` containing the serialized data and a pointer to the deserialized
 * data of type `FlatbufferType`. This allows for efficient storage and access to both the raw
 * serialized data and its parsed form.
 *
 * @tparam FlatbufferType The type of the FlatBuffers object that this struct represents.
 */
template<typename FlatbufferType>
struct FlatbufferDataPair
{
    /**
     * @brief A slice to the serialized FlatBuffers data.
     *
     * The `slice` member stores a `rocksdb::PinnableSlice` that contains the serialized
     * FlatBuffers data.
     */
    rocksdb::PinnableSlice slice;

    /**
     * @brief A pointer to the deserialized FlatBuffers data.
     *
     * The `data` member is a pointer to the deserialized FlatBuffers data of type `FlatbufferType`.
     * It provides direct access to the parsed information.
     */
    const FlatbufferType* data;
};

using namespace NSVulnerabilityScanner;

/**
 * @brief DatabaseFeedManager class.
 *
 * @tparam TIndexerConnector Indexer connector type.
 * @tparam TPolicyManager Policy manager type.
 * @tparam TContentRegister Content register type.
 * @tparam TRouterSubscriber Router subscriber type.
 */
template<typename TIndexerConnector = IndexerConnector,
         typename TPolicyManager = PolicyManager,
         typename TContentRegister = ContentRegister,
         typename TRouterSubscriber = RouterSubscriber>
class TDatabaseFeedManager final : public Observer<nlohmann::json&>
{
public:
    /**
     * @brief Class constructor.
     *
     * @param indexerConnector Indexer connector.
     */
    // TODO: Remove LCOV flags once the implementation of the 'Indexer Connector' module is completed
    // LCOV_EXCL_START
    explicit TDatabaseFeedManager(std::shared_ptr<TIndexerConnector> indexerConnector)
        : Observer("database_feed_manager")
        , m_indexerConnector(indexerConnector)
    {

        const auto updaterPolicy = TPolicyManager::instance().getUpdaterConfiguration();
        // Vulnerability content updater initialization.
        m_contentRegistration = std::make_unique<TContentRegister>(
            updaterPolicy.at("topicName"), TPolicyManager::instance().getUpdaterConfiguration());

        m_descriptionsDatabase = std::make_unique<Utils::RocksDBWrapper>(DESCRIPTION_DATABASE_PATH);
        m_remediationsDatabase = std::make_unique<Utils::RocksDBWrapper>(REMEDIATIONS_DATABASE_PATH);

        // Subscription to vulnerability detector content update events.
        m_contentUpdateSubscription =
            std::make_unique<TRouterSubscriber>(updaterPolicy.at("topicName"), "vulnerability_feed_manager");

        m_contentUpdateSubscription->subscribe(
            [this](const std::vector<char>& message)
            {
                std::cout << "DatabaseFeedManager::update" << std::endl;
                auto eventContext = std::make_shared<EventContext>(EventContext {.message = message});
                auto eventDecoder = std::make_shared<EventDecoder>();
                eventDecoder->setLast(std::make_shared<StoreModel>());
                eventDecoder->setLast(std::make_shared<FeedIndexer<TIndexerConnector>>(m_indexerConnector));
                eventDecoder->setLast(std::make_shared<ScanDispatcher>());

                eventDecoder->handleRequest(eventContext);
            });
    }

    /**
     * @brief Get the Vulnerabilities Candidates information.
     *
     * @param cnaName RocksDB table identifier.
     * @param context Scan context structure.
     * @param callback Store vulnerability data.
     */
    void getVulnerabilitiesCandidates(const std::string& cnaName,
                                      const ScanContext& context,
                                      const std::function<bool(const char* data, const size_t size)>& callback)
    {
        std::string packageName;
        std::string rocksDBKey;

        // TODO: Process cnaName to get the required database path, now harcoded in ROCKS_DB_PATH

        try
        {
            Utils::RocksDBWrapper rocksDBWrapper(ROCKS_DB_PATH);
            if (!context.contextData.empty())
            {
                try
                {
                    packageName = context.contextData.at("data").at("name");
                    for (const auto& [key, value] : rocksDBWrapper.seek(packageName))
                    {
                        if (callback(reinterpret_cast<const char*>(value.data()), value.size()))
                        {
                            // Logging
                        }
                    }
                }
                catch (...)
                {
                    // Loggin
                    std::cerr << "Invalid package\n";
                }
            }
        }
        catch (...)
        {
            // Loggin
            std::cerr << "Unable to open database\n";
        }
    }

    /**
     * @brief Updates scheduler interval.
     *
     * @param data Data containing the interval.
     */
    void update(nlohmann::json& data) override
    {
        m_contentRegistration->changeSchedulerInterval(data.at("updater").at("interval").get<size_t>());
    }
    // LCOV_EXCL_STOP

    /**
     * @brief Gets descriptive information for a cveid.
     *
     * @param cveId cveid to search.
     * @param resultContainer container struct to store the result.
     */
    void getVulnerabiltyDescriptiveInformation(const std::string_view cveId,
                                               FlatbufferDataPair<VulnerabilityDescription>& resultContainer)
    {
        if (m_descriptionsDatabase->get(std::string(cveId), resultContainer.slice) == false)
        {
            throw std::runtime_error(
                "Error getting VulnerabilityDescription object from rocksdb. Object not found for cveId: " +
                std::string(cveId));
        }

        flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(resultContainer.slice.data()),
                                       resultContainer.slice.size());
        if (NSVulnerabilityScanner::VerifyVulnerabilityDescriptionBuffer(verifier) == false)
        {
            throw std::runtime_error(
                "Error getting VulnerabilityDescription object from rocksdb. FlatBuffers verifier failed");
        }

        resultContainer.data = const_cast<NSVulnerabilityScanner::VulnerabilityDescription*>(
            NSVulnerabilityScanner::GetVulnerabilityDescription(resultContainer.slice.data()));
    }

private:
    std::unique_ptr<TRouterSubscriber> m_contentUpdateSubscription;
    std::unique_ptr<TContentRegister> m_contentRegistration;
    std::shared_ptr<TIndexerConnector> m_indexerConnector;
    std::unique_ptr<Utils::RocksDBWrapper> m_descriptionsDatabase;
    std::unique_ptr<Utils::RocksDBWrapper> m_remediationsDatabase;
    std::map<std::string, std::unique_ptr<Utils::RocksDBWrapper>> m_feedsDatabases;
};

using DatabaseFeedManager = TDatabaseFeedManager<>;

#endif // _DATABASE_FEED_MANAGER_HPP
