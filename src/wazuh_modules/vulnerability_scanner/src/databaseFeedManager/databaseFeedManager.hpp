/*
 * Wazuh Vulnerability scanner
 * Copyright (C) 2015, Wazuh Inc.
 * March 25, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _DATABASE_FEED_MANAGER_HPP
#define _DATABASE_FEED_MANAGER_HPP

#include "../policyManager/policyManager.hpp"
#include "../scanOrchestrator/scanContext.hpp"
#include "HTTPRequest.hpp"
#include "UNIXSocketRequest.hpp"
#include "cacheLRU.hpp"
#include "contentManager.hpp"
#include "contentRegister.hpp"
#include "eventDecoder.hpp"
#include "feedIndexer.hpp"
#include "indexerConnector.hpp"
#include "jsonArrayParser.hpp"
#include "loggerHelper.h"
#include "observer.hpp"
#include "rocksDBWrapper.hpp"
#include "routerSubscriber.hpp"
#include "scanDispatcher.hpp"
#include "storeModel.hpp"
#include "updateCVECandidates.hpp"
#include "updateCVEDescription.hpp"
#include "vulnerabilityCandidate_generated.h"
#include "vulnerabilityDescription_generated.h"
#include "vulnerabilityRemediations_generated.h"
#include "vulnerabilityScanner.hpp"
#include <external/nlohmann/json.hpp>
#include <fstream>
#include <functional>
#include <memory>
#include <string>
#include <vector>

constexpr auto REMEDIATIONS_DATABASE_PATH {"queue/vd/remediations"};
constexpr auto TRANSLATIONS_DATABASE_PATH {"queue/vd/translations"};
constexpr auto CVES_DATABASE_PATH {"queue/vd/cves"};

using namespace NSVulnerabilityScanner;

/**
 * @brief A struct for storing a pair of FlatBuffers data.
 *
 * The `FlatbufferDataPair` struct is designed to store a pair of related FlatBuffers data:
 * a `rocksdb::PinnableSlice` containing the serialized data and a pointer to the deserialized
 * data of type `FlatbufferType`. This allows for efficient storage and access to both the raw
 * serialized data and its parsed form.
 *
 * @tparam FlatbufferType The type of the FlatBuffers object that this struct represents.
 */
template<typename FlatbufferType>
struct FlatbufferDataPair final
{
    /**
     * @brief A slice to the serialized FlatBuffers data.
     *
     * The `slice` member stores a `rocksdb::PinnableSlice` that contains the serialized
     * FlatBuffers data.
     */
    rocksdb::PinnableSlice slice;

    /**
     * @brief A pointer to the deserialized FlatBuffers data.
     *
     * The `data` member is a pointer to the deserialized FlatBuffers data of type `FlatbufferType`.
     * It provides direct access to the parsed information.
     */
    const FlatbufferType* data;
};

/**
 * @brief Class to process the message received by the router.
 *
 */
class DatabaseFeedManagerMessageProcessor final
{
public:
    /**
     * @brief Process and validated the message received by the router.
     *
     * @param message Message received by the router.
     * @param orchestration Chain of actions to execute for each valid resource extracted from the message.
     * @param databaseCleanup Database cleanup function to execute if message type is raw.
     * @param shouldStop Variable to control the stop of the processing operations.
     */
    void static processMessage(const std::vector<char>& message,
                               const std::function<void(const nlohmann::json&)>& orchestration,
                               const std::function<void(void)>& databaseCleanup,
                               const std::atomic<bool>& shouldStop)
    {
        auto parsedMessage = nlohmann::json::parse(message, nullptr, false);

        if (parsedMessage.is_discarded() || !parsedMessage.contains("paths") || !parsedMessage.contains("type"))
        {
            throw std::runtime_error("Invalid message");
        }

        if (parsedMessage.at("type") == "offsets")
        {
            auto jsonPointer {"/data"_json_pointer};
            auto callbackSAXParser {[&](nlohmann::json&& item)
                                    {
                                        orchestration(item);
                                        return !shouldStop.load();
                                    }};
            for (const auto& path : parsedMessage.at("paths"))
            {
                if (shouldStop.load())
                {
                    break;
                }
                logInfo(WM_VULNSCAN_LOGTAG, "Processing file: %s", path.get_ref<const std::string&>().c_str());
                JsonArray::parse(path, callbackSAXParser, jsonPointer);
            }
        }
        else if (parsedMessage.at("type") == "raw")
        {
            if (parsedMessage.at("paths").size() != 1)
            {
                throw std::runtime_error("Invalid message");
            }

            databaseCleanup();

            for (const auto& path : parsedMessage.at("paths"))
            {
                logInfo(WM_VULNSCAN_LOGTAG, "Processing file: %s", path.get_ref<const std::string&>().c_str());
                std::ifstream file(path.get_ref<const std::string&>());
                if (!file.is_open())
                {
                    throw std::runtime_error("Unable to open input file: " + path.get_ref<const std::string&>());
                }

                std::string line;
                while (std::getline(file, line))
                {
                    if (shouldStop.load())
                    {
                        break;
                    }

                    nlohmann::json parsedLine = nlohmann::json::parse(line, nullptr, false);
                    if (parsedLine.is_discarded() || !parsedLine.contains("name"))
                    {
                        throw std::runtime_error("Invalid line. file: " + path.get_ref<const std::string&>());
                    }

                    parsedLine["resource"] = parsedLine["name"];
                    parsedLine["type"] = "create";
                    orchestration(parsedLine);
                }
            }
        }
        else
        {
            throw std::runtime_error("Invalid message");
        }

        nlohmann::json data;
        data["offset"] = parsedMessage.at("offset");
        data["topicName"] = PolicyManager::instance().getUpdaterConfiguration().at("topicName");

        UNIXSocketRequest::instance().put(
            HttpUnixSocketURL(ONDEMAND_SOCK, "http://localhost/offset"),
            data,
            [](const std::string& msg) {},
            [](const std::string& msg, const long responseCode)
            { throw std::runtime_error("Error updating offset: " + msg); });
    }
};

/**
 * @brief DatabaseFeedManager class.
 *
 * @tparam TIndexerConnector Indexer connector type.
 * @tparam TPolicyManager Policy manager type.
 * @tparam TContentRegister Content register type.
 * @tparam TRouterSubscriber Router subscriber type.
 */
template<typename TIndexerConnector = IndexerConnector,
         typename TPolicyManager = PolicyManager,
         typename TContentRegister = ContentRegister,
         typename TRouterSubscriber = RouterSubscriber,
         typename TMessageProcessor = DatabaseFeedManagerMessageProcessor>
class TDatabaseFeedManager final : public Observer<nlohmann::json&>
{
public:
    /**
     * @brief Class constructor.
     *
     * @param indexerConnector Indexer connector.
     * @param shouldStop Variable to control the graceful shutdown of the module.
     * @param isLocalSubscriber Configures the router subscription lambda execution as local or remote.
     */
    // TODO: Remove LCOV flags once the implementation of the 'Indexer Connector' module is completed
    // LCOV_EXCL_START
    explicit TDatabaseFeedManager(std::shared_ptr<TIndexerConnector> indexerConnector,
                                  const std::atomic<bool>& shouldStop,
                                  bool isLocalSubscriber = true)
        : Observer("database_feed_manager")
        , m_indexerConnector(indexerConnector)
        , m_shouldStop(shouldStop)
    {
        const auto updaterPolicy = TPolicyManager::instance().getUpdaterConfiguration();
        const std::string topicName = updaterPolicy.at("topicName");

        m_descriptionsDatabase = std::make_unique<Utils::RocksDBWrapper>(DESCRIPTION_DATABASE_PATH);
        m_remediationsDatabase = std::make_unique<Utils::RocksDBWrapper>(REMEDIATIONS_DATABASE_PATH);
        m_translationsDatabase = std::make_unique<Utils::RocksDBWrapper>(TRANSLATIONS_DATABASE_PATH);

        m_translationsCache =
            std::make_unique<LRUCache<std::string, std::string>>(TPolicyManager::instance().getTranslationLRUSize());
        m_cvesDatabase = std::make_unique<Utils::RocksDBWrapper>(CVES_DATABASE_PATH);

        // Subscription to vulnerability detector content update events.
        m_contentUpdateSubscription =
            std::make_unique<TRouterSubscriber>(topicName, "vulnerability_feed_manager", isLocalSubscriber);

        m_contentUpdateSubscription->subscribe(
            [&, topicName](const std::vector<char>& message)
            {
                auto eventDecoder = std::make_shared<EventDecoder>();
                eventDecoder->setLast(std::make_shared<StoreModel>(
                    m_feedsDatabases, m_descriptionsDatabase.get(), m_remediationsDatabase.get()));
                eventDecoder->setLast(std::make_shared<FeedIndexer<TIndexerConnector>>(m_indexerConnector));
                eventDecoder->setLast(std::make_shared<ScanDispatcher>());

                auto orchestrationLambda = [&](const nlohmann::json& resource)
                {
                    auto eventContext =
                        std::make_shared<EventContext>(EventContext {.message = message,
                                                                     .resource = resource,
                                                                     .cvesDatabase = m_cvesDatabase,
                                                                     .translationsDatabase = m_translationsDatabase,
                                                                     .resourceType = ResourceType::UNKNOWN});
                    eventDecoder->handleRequest(eventContext);
                };
                auto databaseCleanupLambda = [&]()
                {
                    m_descriptionsDatabase->deleteAll();
                    m_remediationsDatabase->deleteAll();
                    m_translationsDatabase->deleteAll();
                    m_cvesDatabase->deleteAll();

                    for (auto& [name, database] : m_feedsDatabases)
                    {
                        database->deleteAll();
                    }
                };
                try
                {
                    logInfo(WM_VULNSCAN_LOGTAG, "Processing message");
                    TMessageProcessor::processMessage(
                        message, orchestrationLambda, databaseCleanupLambda, m_shouldStop);
                    logInfo(WM_VULNSCAN_LOGTAG, "Message processed");

                    // Compact the database
                    logInfo(WM_VULNSCAN_LOGTAG, "Compacting CVE5 database");
                    m_cvesDatabase->compactDatabaseUsingBzip2();
                    logInfo(WM_VULNSCAN_LOGTAG, "CVE5 database compacted successfully");
                    logInfo(WM_VULNSCAN_LOGTAG, "Compacting description, remediation, translation and feed databases");
                    m_descriptionsDatabase->compactDatabase();
                    m_remediationsDatabase->compactDatabase();
                    m_translationsDatabase->compactDatabase();
                    for (const auto& [key, db] : m_feedsDatabases)
                    {
                        db->compactDatabase();
                    }
                    logInfo(WM_VULNSCAN_LOGTAG, "Databases compacted successfully");
                }
                catch (const std::exception& e)
                {
                    logError(WM_VULNSCAN_LOGTAG, "Error processing message: %s", e.what());

                    const std::string url = "http://localhost/ondemand/" + topicName + "?offset=0";
                    UNIXSocketRequest::instance().get(
                        HttpUnixSocketURL(ONDEMAND_SOCK, url),
                        [](const std::string& msg) { std::cout << msg << std::endl; },
                        [](const std::string& msg, const long responseCode)
                        {
                            std::cerr << msg << ": " << responseCode << std::endl;
                            throw std::runtime_error(msg);
                        });
                }
            });

        // Vulnerability content updater initialization.
        m_contentRegistration =
            std::make_unique<TContentRegister>(topicName, TPolicyManager::instance().getUpdaterConfiguration());
    }

    /**
     * @brief Retrieves vulnerability remediation information from the database.
     *
     * This function retrieves remediation information associated with a given CVE ID
     * from the underlying database and stores it in the provided `dtoVulnRemediation`
     * object.
     *
     * @param cveId The CVE ID for which remediation information is requested.
     * @param dtoVulnRemediation A reference to a `FlatbufferDataPair` object
     *        where the retrieved remediation information will be stored.
     *
     * @throws std::runtime_error if the value for the specified `cveId` does not exist
     *         in the database.
     * @throws std::runtime_error if the retrieved data from the database is invalid or
     *         not in the expected FlatBuffers format.
     */
    void getVulnerabilityRemediation(const std::string& cveId, FlatbufferDataPair<RemediationInfo>& dtoVulnRemediation)
    {
        auto result = m_remediationsDatabase->get(cveId, dtoVulnRemediation.slice);

        if (!result)
        {
            throw std::runtime_error("Value for key " + cveId + " does not exist in database.");
        }

        flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(dtoVulnRemediation.slice.data()),
                                       dtoVulnRemediation.slice.size());
        if (!VerifyRemediationInfoBuffer(verifier))
        {
            throw std::runtime_error("Error: Invalid FlatBuffers data in RocksDB.");
        }

        dtoVulnRemediation.data = GetRemediationInfo(reinterpret_cast<const uint8_t*>(dtoVulnRemediation.slice.data()));
    }

    /**
     * @brief Retrieves a translation for a given package name using the Wazuh package translation system.
     *
     * This function first checks if the translation is available in a cache, and if not, it looks up the translation
     * in a database and caches the result for future use. If a translation is found, the provided callback function
     * is called for each translation entry.
     *
     * @param packageName The name of the package for which translation is needed.
     * @param callback A callback function that will be invoked for each translation entry found.
     *                The callback function should take a single argument of type
     * `NSVulnerabilityScanner::TranslationEntry`.
     *
     * @note This function assumes the existence of several member variables like `m_translationsCache`,
     *       `m_translationsDatabase`, and the necessary data structures and methods, which are used for caching
     *       and querying package translations.
     */
    void
    getWazuhPackageTranslation(const std::string& packageName,
                               const std::function<void(const NSVulnerabilityScanner::TranslationEntry&)>& callback)
    {
        auto resultCache = m_translationsCache->getValue(packageName);

        // If the translation is in the cache, use it to look up the translation in the database.
        if (resultCache.has_value())
        {
            FlatbufferDataPair<TranslationEntry> dtoVulnTranslation;

            auto resultQuery = m_translationsDatabase->get(resultCache.value(), dtoVulnTranslation.slice);
            if (!resultQuery)
            {
                throw std::runtime_error("Value for key " + resultCache.value() + " does not exist in database.");
            }

            flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(dtoVulnTranslation.slice.data()),
                                           dtoVulnTranslation.slice.size());
            if (!VerifyTranslationEntryBuffer(verifier))
            {
                throw std::runtime_error("Error: Invalid FlatBuffers data in RocksDB.");
            }

            dtoVulnTranslation.data =
                GetTranslationEntry(reinterpret_cast<const uint8_t*>(dtoVulnTranslation.slice.data()));

            callback(*dtoVulnTranslation.data);
        }

        // If the translation is not in the cache, iterate over all the translations in the database and look for
        // a match.
        for (const auto& [key, value] : m_translationsDatabase->begin())
        {
            flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(value.data()), value.size());
            if (!VerifyTranslationEntryBuffer(verifier))
            {
                throw std::runtime_error("Error: Invalid FlatBuffers data in RocksDB.");
            }

            auto queryData = GetTranslationEntry(reinterpret_cast<const uint8_t*>(value.data()));
            std::regex product_pattern {queryData->source()->product()->str()};
            if (std::regex_match(packageName, product_pattern))
            {
                callback(*queryData);

                m_translationsCache->insertKey(packageName, key);
                break;
            }
        }
    }

    /**
     * @brief Get the Vulnerabilities Candidates information.
     *
     * @param cnaName RocksDB table identifier.
     * @param packageName Package name.
     * @param callback Store vulnerability data.
     */
    void getVulnerabilitiesCandidates(
        const std::string& cnaName,
        std::string_view packageName,
        const std::function<bool(const std::string& cnaName,
                                 const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>& callback)
    {
        if (packageName.empty() || cnaName.empty())
        {
            throw std::runtime_error("Invalid package/cna name.");
        }

        CandidatesDBHelper::findAndOpen(cnaName, m_feedsDatabases, true);
        std::string packageNameWithSeparator;
        packageNameWithSeparator.append(packageName);
        packageNameWithSeparator.append("_CVE");

        for (const auto& [key, value] : m_feedsDatabases.at(cnaName)->seek(packageNameWithSeparator))
        {
            auto candidatesArray = GetScanVulnerabilityCandidateArray(reinterpret_cast<const uint8_t*>(value.data()));

            if (candidatesArray)
            {
                for (const auto& candidate : *candidatesArray->candidates())
                {
                    if (callback(cnaName, *candidate))
                    {
                        // If the candidate is vulnerable, we stop looking for.
                        break;
                    }
                }
            }
        }
    }

    /**
     * @brief Retrieves a reference to the CVE (Common Vulnerabilities and Exposures) database.
     *
     * This function provides access to the Common Vulnerabilities and Exposures (CVE) database
     * represented by a reference to a RocksDBWrapper object.
     *
     * @return A reference to the CVE database represented by Utils::RocksDBWrapper.
     */
    Utils::RocksDBWrapper& getCVEDatabase()
    {
        return *m_cvesDatabase;
    }

    /**
     * @brief Updates scheduler interval.
     *
     * @param data Data containing the interval.
     */
    void update(nlohmann::json& data) override
    {
        m_contentRegistration->changeSchedulerInterval(data.at("updater").at("interval").get<size_t>());
    }
    // LCOV_EXCL_STOP

    /**
     * @brief Gets descriptive information for a cveid.
     *
     * @param cveId cveid to search.
     * @param resultContainer container struct to store the result.
     */
    void getVulnerabiltyDescriptiveInformation(const std::string_view cveId,
                                               FlatbufferDataPair<VulnerabilityDescription>& resultContainer)
    {
        if (m_descriptionsDatabase->get(std::string(cveId), resultContainer.slice) == false)
        {
            throw std::runtime_error(
                "Error getting VulnerabilityDescription object from rocksdb. Object not found for cveId: " +
                std::string(cveId));
        }

        flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(resultContainer.slice.data()),
                                       resultContainer.slice.size());
        if (NSVulnerabilityScanner::VerifyVulnerabilityDescriptionBuffer(verifier) == false)
        {
            throw std::runtime_error(
                "Error getting VulnerabilityDescription object from rocksdb. FlatBuffers verifier failed");
        }

        resultContainer.data = const_cast<NSVulnerabilityScanner::VulnerabilityDescription*>(
            NSVulnerabilityScanner::GetVulnerabilityDescription(resultContainer.slice.data()));
    }

    /**
     * @brief Get CNA/ADP name based on the package vendor.
     * @param vendor Package vendor.
     * @return CNA/ADP name.
     */
    std::string getCnaName(std::string_view vendor)
    {
        const static std::map<std::string, std::string> vendorToCnaName = {{"canonical", "canonical"},
                                                                           {"ubuntu", "canonical"},
                                                                           {"debian", "debian"},
                                                                           {"red hat, inc.", "redhat"},
                                                                           {"centos", "redhat"},
                                                                           {"amazon linux", "alas"},
                                                                           {"amazon.com", "alas"},
                                                                           {"amazon aws", "alas"},
                                                                           {"arch linux", "arch"},
                                                                           {"suse", "suse"},
                                                                           {"almalinux", "almalinux"},
                                                                           {"cloudlinux", "almalinux"}};

        const auto vendorLowerCase = Utils::toLowerCase(vendor.data());
        const auto it = std::find_if(vendorToCnaName.begin(),
                                     vendorToCnaName.end(),
                                     [&](const auto& pair) { return Utils::startsWith(vendorLowerCase, pair.first); });

        if (it == vendorToCnaName.end())
        {
            return "nvd";
        }
        return it->second;
    }

private:
    /**
     * Do not change the order of definition of these variables.
     * Since it is important at the object destruction time.
     */
    std::shared_ptr<TIndexerConnector> m_indexerConnector;
    std::unique_ptr<TContentRegister> m_contentRegistration;
    std::unique_ptr<Utils::RocksDBWrapper> m_descriptionsDatabase;
    std::unique_ptr<Utils::RocksDBWrapper> m_remediationsDatabase;
    std::unique_ptr<Utils::RocksDBWrapper> m_translationsDatabase;
    std::unique_ptr<LRUCache<std::string, std::string>> m_translationsCache;
    std::unique_ptr<Utils::RocksDBWrapper> m_cvesDatabase;
    std::map<std::string, std::unique_ptr<Utils::RocksDBWrapper>> m_feedsDatabases;
    std::unique_ptr<TRouterSubscriber> m_contentUpdateSubscription;
    const std::atomic<bool>& m_shouldStop;
};

using DatabaseFeedManager = TDatabaseFeedManager<>;

#endif // _DATABASE_FEED_MANAGER_HPP
