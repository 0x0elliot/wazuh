/*
 * Wazuh Vulnerability scanner - Database Feed Manager
 * Copyright (C) 2015, Wazuh Inc.
 * Oct 6, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _UPDATE_CVE_CANDIDATES_HPP
#define _UPDATE_CVE_CANDIDATES_HPP

#include "cve5_generated.h"
#include "databaseFeedManager.hpp"
#include "flatbuffers/flatbuffers.h"
#include "vulnerabilityCandidate_generated.h"

const std::unordered_map<std::string, std::string> PROVIDERS_ID_MAP = {
    {"00000000-0000-4000-A000-000000000000", "Canonical"},
    {"00000000-0000-4000-A000-000000000001", "NVD"},
    {"79363d38-fa19-49d1-9214-5f28da3f3ac5", "Debian"},
    {"53f830b8-0a3f-465b-8143-3b8a9948e749", "RedHat"},
    {"404e59f5-483d-4b8a-8e7a-e67604dd8afb", "SUSE"}};

const std::unordered_map<std::string, NSVulnerabilityScanner::Status> VERSION_STATUS_MAP {
    {"unaffected", NSVulnerabilityScanner::Status::Status_unaffected},
    {"affected", NSVulnerabilityScanner::Status::Status_affected},
    {"unknown", NSVulnerabilityScanner::Status::Status_unknown}};

/**
 * @brief UpdateCVECandidates class.
 *
 */
class UpdateCVECandidates final
{
public:
    /**
     * @brief Inserts the candidate data into the corresponding database.
     *
     * @param resource CVE ID.
     * @param cve5Flatbuffer CVE5 Flatbuffer.
     * @param DBMap map with rocksDB instances.
     */
    static void storeVulnerabilityCandidate(const std::string& resource,
                                            const cve_v5::Entry* cve5Flatbuffer,
                                            std::unordered_map<std::string, Utils::RocksDBWrapper>& DBMap)
    {
        if (!cve5Flatbuffer || !cve5Flatbuffer->containers())
        {
            return;
        }

        flatbuffers::FlatBufferBuilder builder;

        auto candidateLambda = [&](const cve_v5::Affected* affected, const std::string& containerId)
        {
            if (!affected->product())
            {
                return;
            }

            auto cveIdFB = builder.CreateString(resource);

            std::vector<flatbuffers::Offset<NSVulnerabilityScanner::Version>> versionFBArray;

            if (affected->versions())
            {
                for (const auto& versionElement : *affected->versions())
                {
                    NSVulnerabilityScanner::Status status;
                    flatbuffers::Offset<flatbuffers::String> version;
                    flatbuffers::Offset<flatbuffers::String> lessThan;
                    flatbuffers::Offset<flatbuffers::String> lessThanOrEqual;
                    flatbuffers::Offset<flatbuffers::String> versionType;

                    if (versionElement->status())
                    {
                        status = VERSION_STATUS_MAP.at(versionElement->status()->str());
                    }

                    if (versionElement->version())
                    {
                        version = builder.CreateString(versionElement->version()->str());
                    }

                    if (versionElement->lessThan())
                    {
                        lessThan = builder.CreateString(versionElement->lessThan()->str());
                    }

                    if (versionElement->lessThanOrEqual())
                    {
                        lessThanOrEqual = builder.CreateString(versionElement->lessThanOrEqual()->str());
                    }

                    if (versionElement->versionType())
                    {
                        versionType = builder.CreateString(versionElement->versionType()->str());
                    }

                    NSVulnerabilityScanner::VersionBuilder versionBuilder(builder);
                    versionBuilder.add_status(status);
                    versionBuilder.add_version(version);
                    versionBuilder.add_lessThan(lessThan);
                    versionBuilder.add_lessThanOrEqual(lessThanOrEqual);
                    versionBuilder.add_versionType(versionType);

                    versionFBArray.push_back(versionBuilder.Finish());
                }
            }
            auto versionsFB = builder.CreateVector(versionFBArray);

            std::vector<flatbuffers::Offset<flatbuffers::String>> platformsVec;

            if (affected->platforms())
            {
                for (const auto& platform : *affected->platforms())
                {
                    platformsVec.push_back(builder.CreateString(platform->str()));
                }
            }

            auto platformsFB = builder.CreateVector(platformsVec);

            NSVulnerabilityScanner::ScanVulnerabilityCandidateBuilder scanVulnerabilityCandidateBuilder(builder);

            scanVulnerabilityCandidateBuilder.add_cveId(cveIdFB);
            scanVulnerabilityCandidateBuilder.add_versions(versionsFB);

            if (affected->defaultStatus())
            {
                scanVulnerabilityCandidateBuilder.add_defaultStatus(
                    VERSION_STATUS_MAP.at(affected->defaultStatus()->str()));
            }

            scanVulnerabilityCandidateBuilder.add_platforms(platformsFB);

            auto candidate = scanVulnerabilityCandidateBuilder.Finish();
            builder.Finish(candidate);

            const uint8_t* buffer = builder.GetBufferPointer();
            size_t flatbufferSize = builder.GetSize();

            const rocksdb::Slice VulnerabilityCandidateSlice(reinterpret_cast<const char*>(buffer), flatbufferSize);

            auto key = affected->product()->str() + "_" + resource;

            DBMap.at(containerId).put(key, VulnerabilityCandidateSlice);
        };

        if (cve5Flatbuffer->containers()->adp())
        {
            for (const auto& adp : *cve5Flatbuffer->containers()->adp())
            {
                if (!adp->providerMetadata() || !adp->providerMetadata()->orgId() || !adp->affected())
                {
                    continue;
                }

                auto containerId = adp->providerMetadata()->orgId()->str();

                for (const auto& affected : *adp->affected())
                {
                    candidateLambda(affected, containerId);
                }
            }
        }

        if (cve5Flatbuffer->containers()->cna())
        {
            auto cna = cve5Flatbuffer->containers()->cna();

            if (!cna->providerMetadata() || !cna->providerMetadata()->orgId() || !cna->affected())
            {
                return;
            }

            auto containerId = cna->providerMetadata()->orgId()->str();

            for (const auto& affected : *cna->affected())
            {
                candidateLambda(affected, containerId);
            }
        }
    }
};

#endif // _UPDATE_CVE_CANDIDATES_HPP
