/*
 * Wazuh Vulnerability scanner - Database Feed Manager
 * Copyright (C) 2015, Wazuh Inc.
 * November 3, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _VERSION_OBJECT_PEP440_HPP
#define _VERSION_OBJECT_PEP440_HPP

#include "iVersionObjectInterface.hpp"
#include <iostream>
#include <memory>
#include <regex>
#include <string>

/**
 * @brief VersionObjectPEP440 class.
 *
 */
class VersionObjectPEP440 final : public IVersionObject
{
private:
    static std::regex parserRegex;
    static std::regex parserVersionStrRegex;
    uint32_t epoch;
    std::string versionStr;
    std::string preReleaseStr;
    uint32_t preReleaseNumber;
    uint32_t postReleaseNumber;
    uint32_t devReleaseNumber;
    bool hasPreRelease;
    bool hasPostRelease;
    bool hasDevRelease;

    /**
     * @brief Comparison method for the versionStr variable members.
     *
     * @param versionStrA versionStr member of object A.
     * @param versionStrB versionStr member of object B.
     * @return 0  if A is equal to B.
     *         -1 if A is less than B.
     *         1  if A is greater than B.
     */
    static int compareVersionStr(const std::string& versionStrA, const std::string& versionStrB)
    {
        std::deque<uint32_t> versionStrSplitA;
        std::sregex_token_iterator itA(versionStrA.begin(), versionStrA.end(), parserVersionStrRegex, -1);
        std::sregex_token_iterator itEndA;
        while (itA != itEndA)
        {
            versionStrSplitA.push_back(static_cast<uint32_t>(std::stoul(itA->str())));
            itA++;
        }

        std::deque<uint32_t> versionStrSplitB;
        std::sregex_token_iterator itB(versionStrB.begin(), versionStrB.end(), parserVersionStrRegex, -1);
        std::sregex_token_iterator itEndB;
        while (itB != itEndB)
        {
            versionStrSplitB.push_back(static_cast<uint32_t>(std::stoul(itB->str())));
            itB++;
        }

        while (versionStrSplitA.size() < versionStrSplitB.size())
        {
            versionStrSplitA.push_back(0);
        }

        while (versionStrSplitB.size() < versionStrSplitA.size())
        {
            versionStrSplitB.push_back(0);
        }

        for (size_t itemIdx = 0; itemIdx < versionStrSplitA.size(); itemIdx++)
        {
            if (versionStrSplitA[itemIdx] < versionStrSplitB[itemIdx])
            {
                return -1;
            }
            if (versionStrSplitA[itemIdx] > versionStrSplitB[itemIdx])
            {
                return 1;
            }
        }

        return 0;
    }

public:
    /**
     * @brief Constructor.
     *
     * @param version version string to create object from.
     */
    VersionObjectPEP440(const std::string& version)
    {
        std::smatch parserMatches;
        if ((std::regex_match(version, parserMatches, parserRegex) == false) || (parserMatches.size() != 7))
        {
            throw std::runtime_error {"Error creating " + std::string(typeid(*this).name())};
        }

        epoch = parserMatches.str(1).empty() ? 0 : static_cast<uint32_t>(std::stoul(parserMatches.str(1)));
        versionStr = parserMatches.str(2);

        preReleaseStr = parserMatches.str(3);
        preReleaseNumber = parserMatches.str(4).empty() ? 0 : static_cast<uint32_t>(std::stoul(parserMatches.str(4)));
        hasPreRelease = (!parserMatches.str(3).empty() && !parserMatches.str(4).empty());

        postReleaseNumber = parserMatches.str(5).empty() ? 0 : static_cast<uint32_t>(std::stoul(parserMatches.str(5)));
        hasPostRelease = !parserMatches.str(5).empty();

        devReleaseNumber = parserMatches.str(6).empty() ? 0 : static_cast<uint32_t>(std::stoul(parserMatches.str(6)));
        hasDevRelease = !parserMatches.str(6).empty();
    }

    virtual ~VersionObjectPEP440() = default;

    /**
     * @brief Returns the VersionObjectType of this class.
     *
     * @return VersionObjectType.
     */
    VersionObjectType getType()
    {
        return VersionObjectType::PEP440;
    }

    /**
     * @brief Comparison operator ==.
     *
     * @param b comparison rhs object.
     * @return true/false according to equality condition.
     */
    bool operator==(const IVersionObject& b) const
    {
        const VersionObjectPEP440* pB = dynamic_cast<const VersionObjectPEP440*>(&b);
        if (pB == nullptr)
        {
            throw std::runtime_error {"Error casting VersionObject type"};
        }
        return (epoch == pB->epoch && !compareVersionStr(versionStr, pB->versionStr) &&
                preReleaseStr == pB->preReleaseStr && preReleaseNumber == pB->preReleaseNumber &&
                postReleaseNumber == pB->postReleaseNumber && devReleaseNumber == pB->devReleaseNumber &&
                hasPreRelease == pB->hasPreRelease && hasPostRelease == pB->hasPostRelease &&
                hasDevRelease == pB->hasDevRelease);
    }

    /**
     * @brief Comparison operator <.
     *
     * @param b comparison rhs object.
     * @return true/false according to less than condition.
     */
    bool operator<(const IVersionObject& b) const
    {
        const VersionObjectPEP440* pB = dynamic_cast<const VersionObjectPEP440*>(&b);
        if (pB == nullptr)
        {
            throw std::runtime_error {"Error casting VersionObject type"};
        }

        if (epoch < pB->epoch)
        {
            return true;
        }
        else if (epoch > pB->epoch)
        {
            return false;
        }

        int resultVersionStr = compareVersionStr(versionStr, pB->versionStr);
        if (resultVersionStr < 0)
        {
            return true;
        }
        else if (resultVersionStr > 0)
        {
            return false;
        }

        if (hasPreRelease && pB->hasPreRelease == false)
        {
            return true;
        }
        else if (hasPreRelease == false && pB->hasPreRelease)
        {
            return false;
        }
        else if (hasPreRelease && pB->hasPreRelease)
        {
            int resultPreReleaseStr = preReleaseStr.compare(pB->preReleaseStr);
            if (resultPreReleaseStr < 0)
            {
                return true;
            }
            else if (resultPreReleaseStr > 0)
            {
                return false;
            }

            if (preReleaseNumber < pB->preReleaseNumber)
            {
                return true;
            }
            else if (preReleaseNumber > pB->preReleaseNumber)
            {
                return false;
            }
        }

        if (hasPostRelease && pB->hasPostRelease == false)
        {
            return false;
        }
        else if (hasPostRelease == false && pB->hasPostRelease)
        {
            return true;
        }
        else if (hasPostRelease && pB->hasPostRelease)
        {
            if (postReleaseNumber < pB->postReleaseNumber)
            {
                return true;
            }
            else if (postReleaseNumber > pB->postReleaseNumber)
            {
                return false;
            }
        }

        if (hasDevRelease && pB->hasDevRelease == false)
        {
            return false;
        }
        else if (hasDevRelease == false && pB->hasDevRelease)
        {
            return true;
        }
        else if (hasDevRelease && pB->hasDevRelease)
        {
            if (devReleaseNumber < pB->devReleaseNumber)
            {
                return true;
            }
            else if (devReleaseNumber > pB->devReleaseNumber)
            {
                return false;
            }
        }

        return false;
    }
};

#endif // _VERSION_OBJECT_PEP440_HPP
