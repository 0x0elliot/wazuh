/*
 * Wazuh Vulnerability scanner - Database Feed Manager
 * Copyright (C) 2015, Wazuh Inc.
 * May 1, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _STORE_REMEDIATIONS_MODEL_HPP
#define _STORE_REMEDIATIONS_MODEL_HPP

#include "vulnerabilityRemediations_generated.h"
#include "cve5_generated.h"
#include "databaseFeedManager.hpp"

using namespace NSVulnerabilityScanner;
using namespace cve_v5;

/**
 * @brief StoreRemediationsModel class.
 *
 */
class StoreRemediationsModel final
{
public:

    explicit StoreRemediationsModel(std::shared_ptr<Utils::RocksDBWrapper> remediationsDatabase)
    {
        m_remediations = remediationsDatabase;
    }

    void updateRemediation(const Entry* data)
    {
        try
        {
            auto remediations = data->containers()->cna()->x_remediations();

            std::string key_str {data->cveMetadata()->cveId()->str()};

            if (remediations->alpine()->size())
            {
                std::for_each(remediations->alpine()->begin(), remediations->alpine()->end(),
                [&key_str](const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *vector)
                {
                    flatbuffers::FlatBufferBuilder builder;

                    std::vector<flatbuffers::Offset<flatbuffers::String>> updates_vec;

                    FlatbufferDataPair<RemediationInfo> query_result;



                    for (auto update = 0; update < vector->size();update++)
                    {
                        updates_vec.emplace_back(vector->Get(update));
                    }

                    auto updates = builder.CreateVector(updates_vec);
                    auto remediation = CreateRemediationInfo(builder, updates);
                    builder.Finish(remediation);

                    rocksdb::Slice value(reinterpret_cast<const char*>(builder.GetBufferPointer()), builder.GetSize());
                    rocksdb::Slice c
                });
            }

            for (int update = 0; update < remediations->GetField)

            for(auto& update: data.at("updates"))
            {
                updates_vec.push_back(builder.CreateString(update));
            }


            m_remediationsDatabase->put(key_str, value);
        }
        catch(...)
        {
            std::cerr<<"Unable to store remediation in database.\n";
        }
    }
private:
    Utils::RocksDBWrapper& database_ref;
    std::shared_ptr<Utils::RocksDBWrapper> m_remediations;

};

#endif // _STORE_REMEDIATIONS_MODEL_HPP
