/*
 * Wazuh Vulnerability scanner - Database Feed Manager
 * Copyright (C) 2015, Wazuh Inc.
 * May 1, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _UPSERT_TRANSLATION_HPP
#define _UPSERT_TRANSLATION_HPP

#include "flatbuffers/flatbuffer_builder.h"
#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/idl.h"
#include "flatbuffers/util.h"
#include "json.hpp"
#include "rocksDBWrapper.hpp"
#include "vulnerabilityTranslationPackages_generated.h"

constexpr auto TRANSLATION_DATABASE_PATH {"queue/vd/translations"};
const std::string FLATBUFFER_PATH {FLATBUFFER_SCHEMAS_DIR "vulnerabilityTranslationPackages.fbs"};
const char* INCLUDE_DIRECTORIES[] = {FLATBUFFER_SCHEMAS_DIR, nullptr};

/**
 * @brief UpsertTranslation class.
 *
 */
class UpsertTranslation
{
private:
    /**
     * @brief Inserts a translation entry in a rocksdb database.
     *
     * @param data JSON with the required information to create or update a translation entry.
     * @param rocksDbWrapper rocksdb wrapper instance.
     */
    static bool insertTranslationEntry(const nlohmann::json& data, Utils::RocksDBWrapper& rocksDbWrapper)
    {
        std::string translationEntryStr;
        bool ret = false;

        if (rocksDbWrapper.get(data.at("resource").get<std::string>(), translationEntryStr))
        {
            std::cerr << "Key already exists." << std::endl;
        }
        else if (data.contains("payload"))
        {
            std::string flatbufferSchemaStr;
            bool valid = (flatbuffers::LoadFile(FLATBUFFER_PATH.c_str(), false, &flatbufferSchemaStr));
            if (!valid)
            {
                std::cerr << "Couldn't load schema file: " << FLATBUFFER_PATH << std::endl;
            }
            else
            {
                const std::string payload = data.at("payload").dump();
                const std::string resource = data.at("resource").get<std::string>();
                flatbuffers::Parser parser;

                valid =
                    (parser.Parse(flatbufferSchemaStr.c_str(), INCLUDE_DIRECTORIES) && parser.Parse(payload.c_str()));
                if (!valid)
                {
                    std::cerr << "Error: " << parser.error_ << std::endl;
                }
                else
                {
                    uint8_t* buf = parser.builder_.GetBufferPointer();
                    size_t flatbufferSize = parser.builder_.GetSize();

                    const rocksdb::Slice translationSlice(reinterpret_cast<const char*>(buf), flatbufferSize);
                    rocksDbWrapper.put(resource, translationSlice);

                    ret = true;
                }
            }
        }
        else
        {
            std::cerr << "No payload data" << std::endl;
        }

        return ret;
    }

    /**
     * @brief Updates a translation entry in a rocksdb database.
     *
     * @param data JSON with the required information to create or update a translation entry.
     * @param rocksDbWrapper rocksdb wrapper instance.
     */
    static bool updateTranslationEntry(const nlohmann::json& data, Utils::RocksDBWrapper& rocksDbWrapper)
    {
        std::string translationEntryStr;
        bool ret = false;

        if (rocksDbWrapper.get(data.at("resource").get<std::string>(), translationEntryStr))
        {
            const std::string resource = data.at("resource").get<std::string>();
            std::string flatbufferSchemaStr;

            if (flatbuffers::LoadFile(FLATBUFFER_PATH.c_str(), false, &flatbufferSchemaStr))
            {
                flatbuffers::Parser parser;
                parser.opts.strict_json = true;

                bool valid = parser.Parse(flatbufferSchemaStr.c_str(), INCLUDE_DIRECTORIES);
                if (!valid)
                {
                    std::cerr << parser.error_ << std::endl;
                }
                else
                {
                    std::string translationEntry;
                    if (!flatbuffers::GenText(parser, translationEntryStr.c_str(), &translationEntry))
                    {
                        try
                        {
                            nlohmann::json translationEntryJSON = nlohmann::json::parse(translationEntry);
                            nlohmann::json translationEntryJSONPatched =
                                translationEntryJSON.patch(data.at("operations"));
                            std::string translationEntryJSONPatchedStr = translationEntryJSONPatched.dump();
                            valid = parser.Parse(translationEntryJSONPatchedStr.c_str());

                            if (!valid)
                            {
                                std::cerr << parser.error_ << std::endl;
                            }
                            else
                            {
                                uint8_t* buf = parser.builder_.GetBufferPointer();
                                size_t flatbufferSize = parser.builder_.GetSize();

                                const rocksdb::Slice translationSlice(reinterpret_cast<const char*>(buf),
                                                                      flatbufferSize);
                                rocksDbWrapper.put(resource, translationSlice);

                                ret = true;
                            }
                        }
                        catch (...)
                        {
                            std::cerr << "Couldn't update translation entry id: " << resource << std::endl;
                        }
                    }
                    else
                    {
                        std::cerr << "Couldn't serialize data." << std::endl;
                    }
                }
            }
            else
            {
                std::cerr << "Couldn't load schema file: " << FLATBUFFER_PATH << std::endl;
            }
        }

        return ret;
    }

public:
    /**
     * @brief Creates or modifies a translation entry in a rocksdb database.
     *
     * @param data JSON with the required information to create or update a translation entry.
     * @param rocksDbWrapper rocksdb wrapper instance.
     */
    static void upsertTranslationEntry(const nlohmann::json& data, Utils::RocksDBWrapper& rocksDbWrapper)
    {
        if (data.contains("data"))
        {
            for (const auto& item : data.at("data"))
            {
                if (item.contains("type") && item.contains("resource"))
                {
                    if (item.at("type").get<std::string>().compare("create") == 0)
                    {
                        if (!insertTranslationEntry(item, rocksDbWrapper))
                        {
                            std::cerr << "Insert translation entry: " << item.at("resource") << " failed." << std::endl;
                        }
                    }
                    else if (item.at("type").get<std::string>().compare("update") == 0)
                    {
                        if (!updateTranslationEntry(item, rocksDbWrapper))
                        {
                            std::cerr << "Update translation entry failed: " << item.at("resource") << std::endl;
                        }
                    }
                    else
                    {
                        std::cerr << "Invalid operation type: " << item.at("type").get<std::string>() << " for "
                                  << item.at("resource") << std::endl;
                    }
                }
                else
                {
                    std::cerr << "Invalid data format. Missing keys." << std::endl;
                }
            }
        }
        else
        {
            std::cerr << "Invalid data format. Missing \"data\" key." << std::endl;
        }
    }
};

#endif // _UPSERT_TRANSLATION_HPP
