/*
 * Wazuh Vulnerability scanner
 * Copyright (C) 2015, Wazuh Inc.
 * March 25, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "vulnerabilityScannerFacade.hpp"
#include "flatbuffers/include/syscollector_deltas_generated.h"
#include "flatbuffers/include/syscollector_synchronization_generated.h"
#include "loggerHelper.h"
#include "messageBuffer_generated.h"
#include "vulnerabilityScanner.hpp"
#include "wazuh_modules/vulnerability_scanner/src/policyManager/policyManager.hpp"

constexpr auto VULNERABILITY_SCANNER_TEMPLATE = "queue/indexer/vd_states_template.json";
constexpr auto DEFAULT_QUEUE_PATH = "queue/sockets/queue";
constexpr auto REPORTS_QUEUE_PATH = "queue/vd/reports";
constexpr auto REPORTS_BULK_SIZE {1};
constexpr auto REPORTS_THREADS_NUMBER {1};
constexpr auto DELAYED_EVENTS_BULK_SIZE {1};
constexpr auto DELAYED_EVENTS_THREADS_NUMBER {1};
constexpr auto MICROSEC_FACTOR {1000000};
constexpr auto DELAYED_EVENTS_QUEUE_PATH = "queue/vd/delayed";
constexpr auto SLEEP_RETRY_THREADS_SEC = 60;

int SOCKET_WAIT = 0;

// TODO: Remove LCOV flags once the implementation of the 'Indexer Connector' module is completed
// LCOV_EXCL_START
void VulnerabilityScannerFacade::start(
    const std::function<void(
        const int, const std::string&, const std::string&, const int, const std::string&, const std::string&, va_list)>&
        logFunction,
    const nlohmann::json& configuration,
    const bool noWaitToStop,
    const bool reloadVendorMapStartup)
{
    try
    {
        const auto getSecondsFromEpoch = []()
        {
            return std::chrono::duration_cast<std::chrono::seconds>(std::chrono::system_clock::now().time_since_epoch())
                .count();
        };

        m_noWaitToStop = noWaitToStop;

        // Initialize logging
        Log::assignLogFunction(logFunction);

        // Policy manager initialization.
        auto& policyManager = PolicyManager::instance();
        policyManager.initialize(configuration);

        // Return if the module is disabled.
        if (!policyManager.isVulnerabilityDetectionEnabled())
        {
            logInfo(WM_VULNSCAN_LOGTAG, "Vulnerability scanner module is disabled");
            return;
        }

        // Indexer connector initialization.
        if (policyManager.isIndexerEnabled())
        {
            const auto& indexerConfig = policyManager.getIndexerConfiguration();
            m_indexerConnector =
                std::make_shared<IndexerConnector>(policyManager.getIndexerConfiguration(),
                                                   indexerConfig.contains("template_path")
                                                       ? indexerConfig.at("template_path").get_ref<const std::string&>()
                                                       : VULNERABILITY_SCANNER_TEMPLATE,
                                                   logFunction);
        }

        // Database feed manager initialization.
        m_databaseFeedManager = std::make_shared<DatabaseFeedManager>(
            m_indexerConnector, m_shouldStop, m_internalMutex, true, reloadVendorMapStartup);

        // Socket client initialization to send vulnerability reports.
        if (configuration.contains("wmMaxEps") && configuration.at("wmMaxEps").is_number())
        {
            m_reportsWait = MICROSEC_FACTOR / configuration.at("wmMaxEps").get<int>();
        }
        m_reportSocketClient =
            std::make_shared<SocketClient<Socket<OSPrimitives, NoHeaderProtocol>, EpollWrapper>>(DEFAULT_QUEUE_PATH);
        m_reportSocketClient->connect(
            [](const char* data, uint32_t size, const char* dataHeader, uint32_t sizeHeader) {}, []() {}, SOCK_DGRAM);
        m_reportDispatcher = std::make_shared<ReportDispatcher>(
            [this](std::queue<std::string>& dataQueue)
            {
                while (!dataQueue.empty())
                {
                    auto& data = dataQueue.front();
                    m_reportSocketClient->send(data.c_str(), data.size());
                    // We wait to keep the maximum number of events per second
                    if (m_reportsWait > 0)
                    {
                        std::this_thread::sleep_for(std::chrono::microseconds(m_reportsWait));
                    }
                    dataQueue.pop();
                }
            },
            REPORTS_QUEUE_PATH,
            REPORTS_BULK_SIZE,
            REPORTS_THREADS_NUMBER);

        // Add subscribers for policy updates.
        policyManager.addSubscriber(m_databaseFeedManager);

        // Init Orchestrator
        auto scanOrchestrator = std::make_shared<ScanOrchestrator>(
            m_indexerConnector, m_databaseFeedManager, m_reportDispatcher, m_internalMutex);

        // Dispatching threads to retry events
        m_delayedDispatcher = std::make_shared<DelayedEventDispatcher>(
            // coverity[copy_constructor_call]
            [&, scanOrchestrator, getSecondsFromEpoch](std::queue<rocksdb::PinnableSlice>& dataQueue)
            {
                auto& returnSlice = dataQueue.front();

                flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(returnSlice.data()),
                                               returnSlice.size());

                if (VerifyMessageBufferBuffer(verifier))
                {
                    auto message = GetMessageBuffer(returnSlice.data());

                    // If the message is newer than <SLEEP_RETRY_THREADS_SEC> second, wait to retry.
                    const auto secondsFromEpoch = getSecondsFromEpoch();
                    if ((message->timestamp() + SLEEP_RETRY_THREADS_SEC) > secondsFromEpoch)
                    {
                        std::unique_lock<std::mutex> lock(m_retryMutex);
                        if (m_retryWait.wait_for(
                                lock,
                                std::chrono::seconds(message->timestamp() + SLEEP_RETRY_THREADS_SEC - secondsFromEpoch),
                                [&] { return m_shouldStop.load(); }))
                        {
                            logDebug1(WM_VULNSCAN_LOGTAG, "Wait canceled. Event postponed.");
                            return;
                        }
                    }

                    if (message->type() == BufferType::BufferType_RSync)
                    {
                        std::variant<const SyscollectorDeltas::Delta*, const SyscollectorSynchronization::SyncMsg*>
                            data = SyscollectorSynchronization::GetSyncMsg(message->data()->data());

                        try
                        {
                            logDebug1(WM_VULNSCAN_LOGTAG, "Retry rsync event.");
                            scanOrchestrator->run(data);
                        }
                        catch (const std::exception& e)
                        {
                            logWarn(WM_VULNSCAN_LOGTAG, "Discarded event: %s", e.what());
                        }
                    }
                    else if (message->type() == BufferType::BufferType_DBSync)
                    {
                        std::variant<const SyscollectorDeltas::Delta*, const SyscollectorSynchronization::SyncMsg*>
                            data = SyscollectorDeltas::GetDelta(message->data()->data());

                        try
                        {
                            logDebug1(WM_VULNSCAN_LOGTAG, "Retry delta event.");
                            scanOrchestrator->run(data);
                        }
                        catch (const std::exception& e)
                        {
                            logWarn(WM_VULNSCAN_LOGTAG, "Discarded event: %s", e.what());
                        }
                    }
                    else
                    {
                        logWarn(WM_VULNSCAN_LOGTAG, "Discarded unknown event.");
                    }
                }
                else
                {
                    logWarn(WM_VULNSCAN_LOGTAG, "Discarded unknown event.");
                }

                dataQueue.pop();
            },
            DELAYED_EVENTS_QUEUE_PATH,
            DELAYED_EVENTS_BULK_SIZE,
            DELAYED_EVENTS_THREADS_NUMBER);

        m_syscollectorDeltasSubscription =
            std::make_unique<RouterSubscriber>("deltas-syscollector", "vulnerability_scanner_deltas");
        m_syscollectorDeltasSubscription->subscribe(
            // coverity[copy_constructor_call]
            [scanOrchestrator, delayedDispatcher = m_delayedDispatcher, getSecondsFromEpoch](
                const std::vector<char>& message)
            {
                std::variant<const SyscollectorDeltas::Delta*, const SyscollectorSynchronization::SyncMsg*> data =
                    SyscollectorDeltas::GetDelta(message.data());

                try
                {
                    scanOrchestrator->run(data);
                }
                catch (const OsDataException& e)
                {
                    flatbuffers::FlatBufferBuilder builder;

                    auto object = CreateMessageBufferDirect(builder,
                                                            reinterpret_cast<const std::vector<int8_t>*>(&message),
                                                            BufferType::BufferType_DBSync,
                                                            getSecondsFromEpoch());

                    builder.Finish(object);
                    auto bufferData = reinterpret_cast<const char*>(builder.GetBufferPointer());
                    size_t bufferSize = builder.GetSize();
                    const rocksdb::Slice messageSlice(bufferData, bufferSize);
                    delayedDispatcher->push(messageSlice);
                    logDebug1(WM_VULNSCAN_LOGTAG, "%s. Event postponed", e.what());
                }
                catch (const std::exception& e)
                {
                    logError(WM_VULNSCAN_LOGTAG, "ScanOrchestrator::run::Exception: %s", e.what());
                }
            });

        // Subscription to syscollector rsync events.
        m_syscollectorRsyncSubscription =
            std::make_unique<RouterSubscriber>("rsync-syscollector", "vulnerability_scanner_rsync");
        m_syscollectorRsyncSubscription->subscribe(
            // coverity[copy_constructor_call]
            [scanOrchestrator, delayedDispatcher = m_delayedDispatcher, getSecondsFromEpoch](
                const std::vector<char>& message)
            {
                std::variant<const SyscollectorDeltas::Delta*, const SyscollectorSynchronization::SyncMsg*> data =
                    SyscollectorSynchronization::GetSyncMsg(message.data());

                try
                {
                    scanOrchestrator->run(data);
                }
                catch (const OsDataException& e)
                {
                    flatbuffers::FlatBufferBuilder builder;

                    auto object = CreateMessageBufferDirect(builder,
                                                            reinterpret_cast<const std::vector<int8_t>*>(&message),
                                                            BufferType::BufferType_RSync,
                                                            getSecondsFromEpoch());

                    builder.Finish(object);
                    auto bufferData = reinterpret_cast<const char*>(builder.GetBufferPointer());
                    size_t bufferSize = builder.GetSize();
                    const rocksdb::Slice messageSlice(bufferData, bufferSize);
                    delayedDispatcher->push(messageSlice);
                    logDebug1(WM_VULNSCAN_LOGTAG, "%s. Event postponed.", e.what());
                }
                catch (const std::exception& e)
                {
                    logError(WM_VULNSCAN_LOGTAG, "ScanOrchestrator::run::Exception: %s", e.what());
                }
            });

        logInfo(WM_VULNSCAN_LOGTAG, "Vulnerability scanner module started");
    }
    catch (const std::exception& e)
    {
        logError(WM_VULNSCAN_LOGTAG, "VulnerabilityScannerFacade::start: %s", e.what());
    }
    catch (...)
    {
        logError(WM_VULNSCAN_LOGTAG, "VulnerabilityScannerFacade::start: Unknown exception");
    }
}
// LCOV_EXCL_STOP

void VulnerabilityScannerFacade::stop()
{
    if (m_noWaitToStop)
    {
        m_shouldStop.store(true);
    }

    m_retryWait.notify_all();

    m_indexerConnector.reset();
    m_databaseFeedManager.reset();
    m_syscollectorRsyncSubscription.reset();
    m_syscollectorDeltasSubscription.reset();
    PolicyManager::instance().teardown();
    m_reportDispatcher.reset();
    m_delayedDispatcher.reset();
}
