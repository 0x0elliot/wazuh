/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * Jan 22, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef __CLEAN_UP_ALL_HPP
#define __CLEAN_UP_ALL_HPP

#include "chainOfResponsability.hpp"
#include "indexerConnector.hpp"
#include "inventorySync.hpp"
#include "loggerHelper.h"
#include "scanContext.hpp"
#include "socketDBWrapper.hpp"
#include "vulnerabilityScanner.hpp"
#include "wazuhDBQueryBuilder.hpp"

/**
 * @brief A class for handling data cleanup operations in the inventory database and publishing the changes to the
 * indexer.
 *
 * @tparam TIndexerConnector Indexer connector.
 * @tparam TScanContext Scan context.
 */
template<typename TIndexerConnector = IndexerConnector, typename TScanContext = ScanContext>
class TCleanUpData final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    Utils::RocksDBWrapper& m_inventoryDatabase;
    std::shared_ptr<TIndexerConnector> m_indexerConnector;

public:
    /**
     * @brief Class constructor.
     * @param indexerConnector Indexer connector.
     * @param inventoryDatabase Inventory database.
     */
    explicit TCleanUpData(std::shared_ptr<TIndexerConnector> indexerConnector, Utils::RocksDBWrapper& inventoryDatabase)
        : m_indexerConnector(std::move(indexerConnector))
        , m_inventoryDatabase(inventoryDatabase)
    {
    }

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * This method handles cleanup requests based on the operation type specified in the input data.
     * If the operation type is DeleteAll, it deletes all entries from the inventory database, logs the deletions and
     * publishes the changes to the indexer. If the operation type is SingleDeleteAndInsert, it performs specific
     * cleanup actions for entries related to a particular agent, logs those deletions and publishes the changes to the
     * indexer. If the operation type is not recognized, it throws a std::runtime_error.
     *
     * @param data Scan context.
     * @return std::shared_ptr<TScanContext> Abstract handler.
     */
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {
        if (data->operationType() == OperationType::DeleteAll)
        {
            // Check if m_indexerConnector is available before processing.
            if (m_indexerConnector)
            {
                m_inventoryDatabase.deleteAll(
                    [&](const std::string& key, const std::string& value)
                    {
                        // Extract the list of CVEs from the key
                        auto listCve = Utils::split(value, ',');

                        for (const auto& cve : listCve)
                        {
                            std::string elementKey = key + "_" + cve;
                            nlohmann::json json;
                            json["operation"] = "DELETED";
                            json["id"] = elementKey;
                            m_indexerConnector->publish(json.dump());
                        }

                        logDebug2(WM_VULNSCAN_LOGTAG, "Deleting all entries for key prefix: %s", key.c_str());
                    });
            }
            else
            {
                // If m_indexerConnector is nullptr, just delete the entries without publishing.
                logDebug2(WM_VULNSCAN_LOGTAG, "Indexer connector is not available. Skipping publish operation.");
                m_inventoryDatabase.deleteAll();
            }
        }
        else if (data->operationType() == OperationType::SingleDeleteAndInsert)
        {
            std::string agentPackageKey;
            agentPackageKey.append(data->agentNodeName());
            agentPackageKey.append("_");
            agentPackageKey.append(data->agentId());
            agentPackageKey.append("_");

            logDebug2(WM_VULNSCAN_LOGTAG,
                      "Agent '%s' initiating database update: Removing all entries from inventory.",
                      std::string(data->agentId()).c_str());

            // Check if m_indexerConnector is available before processing the queries.
            if (m_indexerConnector)
            {
                for (const auto& dbQuery : m_inventoryDatabase.seek(agentPackageKey))
                {
                    auto listCve = Utils::split(dbQuery.second.ToString(), ',');
                    for (const auto& cve : listCve)
                    {
                        std::string elementKey = dbQuery.first + "_" + cve; // Concatenate strings more efficiently.
                        nlohmann::json json = {{"operation", "DELETED"}, {"id", elementKey}};
                        m_indexerConnector->publish(json.dump());
                        logDebug2(WM_VULNSCAN_LOGTAG, "Entry deletion: %s", elementKey.c_str());
                    }
                    m_inventoryDatabase.delete_(dbQuery.first);
                }
            }
            else
            {
                // If m_indexerConnector is nullptr, just delete the entries without publishing.
                for (const auto& dbQuery : m_inventoryDatabase.seek(agentPackageKey))
                {
                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "Indexer connector is not available. Skipping publish operation for package: %s",
                              dbQuery.first.c_str());
                    m_inventoryDatabase.delete_(dbQuery.first);
                }
            }
        }
        else
        {
            throw std::runtime_error("Invalid operation type in CleanUpData::handleRequest");
        }
        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
};

using CleanUpData = TCleanUpData<>;

#endif // __CLEAN_UP_ALL_HPP
