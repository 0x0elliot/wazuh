/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * March 25, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _SCAN_CONTEXT_HPP
#define _SCAN_CONTEXT_HPP

#include "external/nlohmann/json.hpp"
#include "flatbuffers/include/syscollector_deltas_generated.h"
#include "flatbuffers/include/syscollector_synchronization_generated.h"
#include "logging_helper.h"
#include <functional>
#include <memory>
#include <string>
#include <variant>
#include <vector>

enum class ScannerType
{
    Unknown = 0,
    PackageInsert = 1,
    PackageDelete = 2,
    Os = 3,
    HotfixInsert = 4,
    HotfixDelete = 5,
};

/**
 * @brief ScanContext structure.
 *
 */
struct ScanContext final
{
    /**
     * @brief Class constructor.
     *
     * @param data Scan context.
     */
    // LCOV_EXCL_START
    explicit ScanContext(
        std::variant<const SyscollectorDeltas::Delta*, const SyscollectorSynchronization::SyncMsg*>& data)
    {
        std::visit(
            [this](auto&& arg)
            {
                using T = std::decay_t<decltype(arg)>;
                if constexpr (std::is_same_v<T, const SyscollectorDeltas::Delta*>)
                {
                    m_data = arg;
                    auto delta = std::get<const SyscollectorDeltas::Delta*>(m_data);

                    if (delta->operation())
                    {
                        if (delta->data_type() == SyscollectorDeltas::Provider_dbsync_packages)
                        {
                            // Modify events not exist for packages, because all fields that change in an update are PK.
                            m_type = delta->operation()->str().compare("DELETED") == 0 ? ScannerType::PackageDelete
                                                                                       : ScannerType::PackageInsert;
                        }
                        else if (delta->data_type() == SyscollectorDeltas::Provider_dbsync_osinfo)
                        {
                            m_type = ScannerType::Os;
                        }
                        else if (delta->data_type() == SyscollectorDeltas::Provider_dbsync_hotfixes)
                        {
                            m_type = delta->operation()->str().compare("DELETED") == 0 ? ScannerType::HotfixInsert
                                                                                       : ScannerType::HotfixDelete;
                        }
                    }
                    else
                    {
                        throw std::runtime_error("Operation not found in delta.");
                    }
                }
                else if constexpr (std::is_same_v<T, const SyscollectorSynchronization::SyncMsg*>)
                {

                    m_data = arg;
                    auto syncMsg = std::get<const SyscollectorSynchronization::SyncMsg*>(m_data);

                    if (syncMsg->data_type() == SyscollectorSynchronization::DataUnion_state)
                    {
                        if (syncMsg->data_as_state()->attributes_type() ==
                            SyscollectorSynchronization::AttributesUnion_syscollector_osinfo)
                        {
                            m_type = ScannerType::Os;
                        }
                        else if (syncMsg->data_as_state()->attributes_type() ==
                                 SyscollectorSynchronization::AttributesUnion_syscollector_packages)
                        {
                            m_type = ScannerType::PackageInsert;
                        }
                        else if (syncMsg->data_as_state()->attributes_type() ==
                                 SyscollectorSynchronization::AttributesUnion_syscollector_hotfixes)
                        {
                            m_type = ScannerType::HotfixInsert;
                        }
                    }
                    else
                    {
                        throw std::runtime_error("Data type not found in sync message.");
                    }
                }
                else
                {
                    throw std::runtime_error("Unknown type.");
                }
            },
            data);
    }

    /**
     * @brief Gets scan type.
     *
     * @return Scan type.
     */
    ScannerType getType() const
    {
        return m_type;
    }

    /**
     * @brief Class destructor.
     *
     */
    ~ScanContext() = default;
    // LCOV_EXCL_STOP
private:
    /**
     * @brief Scan type.
     *
     */
    ScannerType m_type = ScannerType::Unknown;

    /**
     * @brief Scan context.
     *
     */
    std::variant<const SyscollectorDeltas::Delta*, const SyscollectorSynchronization::SyncMsg*> m_data;

    // LCOV_EXCL_STOP
};

#endif // _SCAN_CONTEXT_HPP
