/*
 * Wazuh Vulnerability scanner - Database Feed Manager
 * Copyright (C) 2015, Wazuh Inc.
 * December 06, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _VERSION_OBJECT_DPKG_HPP
#define _VERSION_OBJECT_DPKG_HPP

#include "iVersionObjectInterface.hpp"
#include "stringHelper.h"
#include <cctype>
#include <cstring>
#include <iostream>
#include <limits.h>
#include <memory>
#include <regex>
#include <string>

/**
 * @brief DpkgVersion data struct.
 *
 */
struct DpkgVersion
{
    uint32_t epoch;       ///< Epoch.
    std::string version;  ///< Version.
    std::string revision; ///< Revision.
};

/**
 * @brief VersionObjectDpkg class.
 *
 */
class VersionObjectDpkg final : public IVersionObject
{
private:
    DpkgVersion struct_dpkg;
    long m_epoch;
    std::string m_version;
    std::string m_revision;

    /**
     * Give a weight to the character to order in the version comparison.
     *
     * @param c An ASCII character.
     */
    int order(char c) const
    {
        if (std::isdigit(c))
        {
            return 0;
        }
        else if (std::isalpha(c))
        {
            return c;
        }
        else if (c == '~')
        {
            return -1;
        }
        else if (c)
        {
            return c + 256;
        }
        else
        {
            return 0;
        }
    }

    /**
     * Make the version comparison with the upstream version and the debian revision.
     *
     * @param a An array of characters.
     * @param b An array of characters.
     */
    int verrevcmp(const char* a, const char* b) const
    {
        if (a == nullptr)
        {
            a = "";
        }
        if (b == nullptr)
        {
            b = "";
        }

        while (*a || *b)
        {
            int first_diff = 0;

            while ((*a && !std::isdigit(*a)) || (*b && !std::isdigit(*b)))
            {
                int ac = order(*a);
                int bc = order(*b);

                if (ac != bc)
                    return ac - bc;

                a++;
                b++;
            }
            while (*a == '0') a++;
            while (*b == '0') b++;
            while (std::isdigit(*a) && std::isdigit(*b))
            {
                if (!first_diff)
                    first_diff = *a - *b;
                a++;
                b++;
            }

            if (std::isdigit(*a))
                return 1;
            if (std::isdigit(*b))
                return -1;
            if (first_diff)
                return first_diff;
        }

        return 0;
    }

    /**
     * Compares two Debian versions.
     *
     * This function follows the convention of the comparator functions used by
     * qsort().
     *
     * @see deb-version(5)
     *
     * @param r_epoch The second epoch.
     * @param r_version The second version.
     * @param r_revision The second revision.
     *
     * @retval 0 If a and b are equal.
     * @retval <0 If a is smaller than b.
     * @retval >0 If a is greater than b.
     */
    int dpkg_version_compare(const long r_epoch, const std::string& r_version, const std::string& r_revision) const
    {
        int rc;

        if (m_epoch > r_epoch)
            return 1;
        if (m_epoch < r_epoch)
            return -1;

        rc = verrevcmp(m_version.c_str(), r_version.c_str());
        if (rc)
            return rc;

        return verrevcmp(m_revision.c_str(), r_revision.c_str());
    }

    /**
     * Parse a version string and check for invalid syntax.
     *
     * Distinguish between lax (warnings) and strict (error) parsing.
     *
     * @param string The version string to parse.
     * @param dpkgStruct The parsed version.
     *
     * @retval  true  On success.
     * @retval  false On failure.
     */
    static bool parseversion(const char* string, struct DpkgVersion* dpkgStruct)
    {
        const char *end, *ptr;

        /* Trim leading and trailing space. */
        while (*string && std::isspace(*string)) string++;

        if (!*string)
            return false;

        /* String now points to the first non-whitespace char. */
        end = string;
        /* Find either the end of the string, or a whitespace char. */
        while (*end && !std::isspace(*end)) end++;
        /* Check for extra chars after trailing space. */
        ptr = end;
        while (*ptr && std::isspace(*ptr)) ptr++;
        if (*ptr)
            return false;

        auto colon = std::strchr(string, ':');
        if (colon != nullptr)
        {
            long epoch;
            char* eepochcolon;

            errno = 0;
            epoch = std::strtol(string, &eepochcolon, 10);
            if (string == eepochcolon)
                return false;
            if (colon != eepochcolon)
                return false;
            if (epoch < 0)
                return false;
            if (epoch > INT_MAX || errno == ERANGE)
                return false;
            if (!*++colon)
                return false;
            string = colon;
            dpkgStruct->epoch = epoch;
        }
        else
        {
            dpkgStruct->epoch = 0;
        }
        dpkgStruct->version = std::string(string, end - string);
        auto hyphen = const_cast<char*>(std::strchr(dpkgStruct->version.c_str(), '-'));
        if (hyphen != nullptr)
        {
            *hyphen++ = '\0';
            if (*hyphen == '\0')
                return false;
        }
        dpkgStruct->revision = hyphen ? std::string(hyphen) : "";

        /* XXX: Would be faster to use something like cisversion and cisrevision. */
        ptr = dpkgStruct->version.c_str();
        if (!*ptr)
            return false;
        if (!std::isdigit(*ptr++))
            return false;
        for (; *ptr; ptr++)
        {
            if (!std::isdigit(*ptr) && !std::isalpha(*ptr) && strchr(".-+~:", *ptr) == NULL)
                return false;
        }
        for (ptr = dpkgStruct->revision.c_str(); *ptr; ptr++)
        {
            if (!std::isdigit(*ptr) && !std::isalpha(*ptr) && strchr(".+~", *ptr) == NULL)
                return false;
        }

        return true;
    }

public:
    /**
     * @brief Static method to match a version string to a DpkgVersion object.
     *
     * @param version version string to match.
     * @param output DpkgVersion object to store the result.
     * @return true/false according to match condition.
     */
    static bool match(const std::string& version, DpkgVersion& output)
    {
        return parseversion(version.c_str(), &output);
    }
    /**
     * @brief Constructor.
     *
     * @param version version SemVer object.
     */
    explicit VersionObjectDpkg(const DpkgVersion& version)
        : m_epoch {version.epoch}
        , m_version {version.version}
        , m_revision {version.revision}
    {
    }
    // LCOV_EXCL_START
    ~VersionObjectDpkg() override = default;
    // LCOV_EXCL_STOP

    /**
     * @brief Returns the VersionObjectType of this class.
     *
     * @return VersionObjectType.
     */
    VersionObjectType getType() override
    {
        return VersionObjectType::DPKG;
    }

    /**
     * @brief Comparison operator ==.
     *
     * @param b comparison rhs object.
     * @return true/false according to equality condition.
     */
    bool operator==(const IVersionObject& b) const override
    {
        const auto* pB = dynamic_cast<const VersionObjectDpkg*>(&b);
        if (pB == nullptr)
        {
            throw std::runtime_error {"Error casting VersionObject type"};
        }
        return dpkg_version_compare(pB->m_epoch, pB->m_version, pB->m_revision) == 0;
    }

    /**
     * @brief Comparison operator <.
     *
     * @param b comparison rhs object.
     * @return true/false according to less than condition.
     */
    bool operator<(const IVersionObject& b) const override
    {
        const auto* pB = dynamic_cast<const VersionObjectDpkg*>(&b);
        if (pB == nullptr)
        {
            throw std::runtime_error {"Error casting VersionObject type"};
        }
        return dpkg_version_compare(pB->m_epoch, pB->m_version, pB->m_revision) < 0;
    }
};

#endif // _VERSION_OBJECT_DPKG_HPP
