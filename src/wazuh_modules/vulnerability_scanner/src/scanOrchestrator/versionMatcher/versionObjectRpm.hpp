/*
 * Wazuh Vulnerability scanner - Database Feed Manager
 * Copyright (C) 2015, Wazuh Inc.
 * December 14, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _VERSION_OBJECT_RPM_HPP
#define _VERSION_OBJECT_RPM_HPP

#include "iVersionObjectInterface.hpp"
#include "stringHelper.h"
#include <cctype>
#include <cstring>
#include <iostream>
#include <limits.h>
#include <memory>
#include <regex>
#include <string>

/**
 * @brief Rpm data struct.
 *
 */
struct Rpm
{
    std::string rpmVersion; ///< RPM version.
};

/**
 * @brief VersionObjectRpm class.
 *
 */
class VersionObjectRpm final : public IVersionObject
{
private:
    static std::regex m_parserRegex;
    std::string m_rpmVersion;

    /**
     * Compares two RPM versions.
     *
     * This function follows the convention of the comparator functions used by
     * qsort().
     *
     * @see rpmvercmp.c
     *
     * @param rRpmVersion The second RPM version.
     *
     * @retval 0 If a and b are equal.
     * @retval <0 If a is smaller than b.
     * @retval >0 If a is greater than b.
     */
    int compareRpmVersion(const std::string& rRpmVersion) const
    {
        // 1: If the strings are. . .  equal, return 0.
        if (m_rpmVersion == rRpmVersion)
        {
            return 0;
        }
        // use xpos as the beginning of the part of string x remaining to be considered
        std::size_t lhsStrPos = 0, rhsStrPos = 0, lhsStrBeg, rhsStrBeg;
        std::size_t lhsSize = m_rpmVersion.size();
        std::size_t rhsSize = rRpmVersion.size();
        // 2: Loop over the strings, left-to-right.
        while (lhsStrPos < lhsSize && rhsStrPos < rhsSize)
        {
            // 2.1: Trim anything that’s not [A-Za-z0-9] or tilde (~) from the front
            //      of both strings.
            while (lhsStrPos < lhsSize && !(std::isalnum(m_rpmVersion[lhsStrPos]) || m_rpmVersion[lhsStrPos] == '~'))
            {
                lhsStrPos++;
            }
            while (rhsStrPos < rhsSize && !(std::isalnum(rRpmVersion[rhsStrPos]) || rRpmVersion[rhsStrPos] == '~'))
            {
                rhsStrPos++;
            }
            if (lhsStrPos == std::string::npos || rhsStrPos == std::string::npos)
            {
                break;
            }
            // 2.2: If both strings start with a tilde, discard it and move on to the
            //      next character.
            if (m_rpmVersion[lhsStrPos] == '~' && rRpmVersion[rhsStrPos] == '~')
            {
                lhsStrPos++;
                rhsStrPos++;
                // 2.4: End the loop if either string has reached zero length.
                if (lhsStrPos == lhsSize || rhsStrPos == rhsSize)
                {
                    break;
                }
            }
            else if (m_rpmVersion[lhsStrPos] == '~')
            {
                // 2.3: If string a starts with a tilde and string b does not, return -1
                //      (string a is older); and the inverse if string b starts with a
                //      tilde and string a does not.
                return -1;
            }
            else if (rRpmVersion[rhsStrPos] == '~')
            {
                return 1;
            }
            // 2.5: If the first character of a is a digit, pop the leading chunk of
            //      continuous digits from each string
            //(define the 'popped' segment as characters [xseg,xpos) for string x)
            if (std::isdigit(m_rpmVersion[lhsStrPos]))
            {
                lhsStrBeg = lhsStrPos++; // increment lhsStrPos because we know it was a digit
                while (lhsStrPos < lhsSize && std::isdigit(m_rpmVersion[lhsStrPos]))
                {
                    lhsStrPos++;
                }
                rhsStrBeg = rhsStrPos; // rhsStrPos might not be a digit, do not increment
                while (rhsStrPos < rhsSize && std::isdigit(rRpmVersion[rhsStrPos]))
                {
                    rhsStrPos++;
                }
            }
            // 2.5 cont'd: If a begins with a letter, do the same for leading letters.
            if (std::isalpha(m_rpmVersion[lhsStrPos]))
            {
                lhsStrBeg = lhsStrPos++; // increment lhsStrPos because we know it was a letter
                while (lhsStrPos < lhsSize && std::isalpha(m_rpmVersion[lhsStrPos]))
                {
                    lhsStrPos++;
                }
                rhsStrBeg = rhsStrPos; // rhsStrPos might not be a letter, do not increment
                while (rhsStrPos < rhsSize && std::isalpha(rRpmVersion[rhsStrPos]))
                {
                    rhsStrPos++;
                }
            }
            // 2.6: If the segment from b had 0 length, return 1 if the segment from
            //      a was numeric, or -1 if it was alphabetic.
            if (rhsStrPos == rhsStrBeg)
            {
                if (std::isdigit(m_rpmVersion[lhsStrBeg]))
                {
                    return 1;
                }
                if (std::isalpha(m_rpmVersion[lhsStrBeg]))
                {
                    return -1;
                }
            }
            // 2.7: If the leading segments were both numeric, discard any leading
            //      zeros. If a is longer than b (without leading zeroes), return 1,
            //      and vice-versa.
            if (std::isdigit(m_rpmVersion[lhsStrBeg]))
            {
                while (lhsStrBeg < lhsStrPos && m_rpmVersion[lhsStrBeg] == '0')
                { // trim a
                    lhsStrBeg++;
                }
                while (rhsStrBeg < rhsStrPos && rRpmVersion[rhsStrBeg] == '0')
                { // trim b
                    rhsStrBeg++;
                }
                if (lhsStrPos - lhsStrBeg > rhsStrPos - rhsStrBeg)
                { // a is longer than b
                    return 1;
                }
                if (rhsStrPos - rhsStrBeg > lhsStrPos - lhsStrBeg)
                { // b is longer than a
                    return -1;
                }
            }
            // 2.8: Compare the leading segments with strcmp(). If that returns a
            // non-zero value, then return that value.
            //(Implement the equivalent of strcmp inline because segments are
            // not null terminated.)
            while (lhsStrBeg < lhsStrPos && rhsStrBeg < rhsStrPos)
            {
                if (m_rpmVersion[lhsStrBeg] < rRpmVersion[rhsStrBeg])
                {
                    return -1;
                }
                if (m_rpmVersion[lhsStrBeg] > rRpmVersion[rhsStrBeg])
                {
                    return 1;
                }
                lhsStrBeg++;
                rhsStrBeg++;
            }
            if (lhsStrBeg == lhsStrPos && rhsStrBeg < rhsStrPos)
            {
                return -1;
            }
            if (rhsStrBeg == rhsStrPos && lhsStrBeg < lhsStrPos)
            {
                return 1;
            }
        }
        // If the loop ended then the longest wins - if what’s left of a is longer
        // than what’s left of b, return 1. Vice-versa for if what’s left of b is
        // longer than what’s left of a. And finally, if what’s left of them is the
        // same length, return 0.
        if (lhsSize - lhsStrPos > rhsSize - rhsStrPos)
        {
            return 1;
        }
        if (lhsSize - lhsStrPos < rhsSize - rhsStrPos)
        {
            return -1;
        }
        return 0;
    }

public:
    /**
     * @brief Static method to match a version string to a Rpm object.
     *
     * @param version version string to match.
     * @param output Rpm object to store the result.
     * @return true/false according to match condition.
     */
    static bool match(const std::string& version, Rpm& output)
    {
        std::smatch parserMatches;
        if ((std::regex_match(version, parserMatches, m_parserRegex) == false) || (parserMatches.size() != 4))
        {
            return false;
        }

        output.rpmVersion = version;

        return true;
    }
    /**
     * @brief Constructor.
     *
     * @param version version SemVer object.
     */
    explicit VersionObjectRpm(const Rpm& version)
        : m_rpmVersion {version.rpmVersion}
    {
    }
    // LCOV_EXCL_START
    ~VersionObjectRpm() override = default;
    // LCOV_EXCL_STOP

    /**
     * @brief Returns the VersionObjectType of this class.
     *
     * @return VersionObjectType.
     */
    VersionObjectType getType() override
    {
        return VersionObjectType::RPM;
    }

    /**
     * @brief Comparison operator ==.
     *
     * @param b comparison rhs object.
     * @return true/false according to equality condition.
     */
    bool operator==(const IVersionObject& b) const override
    {
        const auto* pB = dynamic_cast<const VersionObjectRpm*>(&b);
        if (pB == nullptr)
        {
            throw std::runtime_error {"Error casting VersionObject type"};
        }

        return compareRpmVersion(pB->m_rpmVersion) == 0;
    }

    /**
     * @brief Comparison operator <.
     *
     * @param b comparison rhs object.
     * @return true/false according to less than condition.
     */
    bool operator<(const IVersionObject& b) const override
    {
        const auto* pB = dynamic_cast<const VersionObjectRpm*>(&b);
        if (pB == nullptr)
        {
            throw std::runtime_error {"Error casting VersionObject type"};
        }
        return compareRpmVersion(pB->m_rpmVersion) == -1;
    }
};

#endif // _VERSION_OBJECT_RPM_HPP
