/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * Jan 22, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef __CLEAN_UP_ALL_HPP
#define __CLEAN_UP_ALL_HPP

#include "chainOfResponsability.hpp"
#include "indexerConnector.hpp"
#include "inventorySync.hpp"
#include "loggerHelper.h"
#include "scanContext.hpp"
#include "socketDBWrapper.hpp"
#include "vulnerabilityScanner.hpp"
#include "wazuhDBQueryBuilder.hpp"

/**
 * @brief A class for handling data cleanup operations in the inventory database and publishing the changes to the
 * indexer.
 *
 * @tparam TIndexerConnector Indexer connector.
 * @tparam TScanContext Scan context.
 */
template<typename TIndexerConnector = IndexerConnector, typename TScanContext = ScanContext>
class TCleanUpData final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    Utils::RocksDBWrapper& m_inventoryDatabase;
    std::shared_ptr<TIndexerConnector> m_indexerConnector;

public:
    /**
     * @brief Class constructor.
     * @param indexerConnector Indexer connector.
     * @param inventoryDatabase Inventory database.
     */
    explicit TCleanUpData(std::shared_ptr<TIndexerConnector> indexerConnector, Utils::RocksDBWrapper& inventoryDatabase)
        : m_indexerConnector(std::move(indexerConnector))
        , m_inventoryDatabase(inventoryDatabase)
    {
        if (m_indexerConnector == nullptr)
        {
            throw std::runtime_error("Indexer connector is null");
        }
    }

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * This method handles cleanup requests based on the operation type specified in the input data.
     * If the operation type is DeleteAll, it deletes all entries from the inventory database, logs the deletions and
     * publishes the changes to the indexer. If the operation type is SingleDeleteAndInsert, it performs specific
     * cleanup actions for entries related to a particular agent, logs those deletions and publishes the changes to the
     * indexer. If the operation type is not recognized, it throws a std::runtime_error.
     *
     * @param data Scan context.
     * @return std::shared_ptr<TScanContext> Abstract handler.
     */
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {
        if (data->operationType() == OperationType::DeleteAll)
        {
            logDebug2(WM_VULNSCAN_LOGTAG, "Deleting all entries from inventory database by trigger request.");
            m_inventoryDatabase.deleteAll(
                [&](const std::string& key)
                {
                    nlohmann::json json;
                    json["operation"] = "DELETED";
                    json["id"] = key;
                    logDebug2(WM_VULNSCAN_LOGTAG, "Deleting entry: %s", key.c_str());
                    m_indexerConnector->publish(json.dump());
                });
        }
        else if (data->operationType() == OperationType::SingleDeleteAndInsert)
        {
            std::string agentPackageKey;
            agentPackageKey.append(data->agentNodeName());
            agentPackageKey.append("_");
            agentPackageKey.append(data->agentId());
            agentPackageKey.append("_");

            logDebug2(WM_VULNSCAN_LOGTAG,
                      "Deleting all entries from inventory database by database update for agent '%s'.",
                      std::string(data->agentId()).c_str());

            for (const auto& dbQuery : m_inventoryDatabase.seek(agentPackageKey))
            {
                auto listCve = Utils::split(dbQuery.second.ToString(), ',');
                for (const auto& cve : listCve)
                {
                    std::string elementKey;
                    nlohmann::json json;
                    elementKey.append(dbQuery.first);
                    elementKey.append("_");
                    elementKey.append(cve);
                    json["operation"] = "DELETED";
                    json["id"] = elementKey;
                    m_indexerConnector->publish(json.dump());
                    logDebug2(WM_VULNSCAN_LOGTAG, "Deleting entry: %s", elementKey.c_str());
                }
                m_inventoryDatabase.delete_(dbQuery.first);
            }
        }
        else
        {
            throw std::runtime_error("Invalid operation type in CleanUpData::handleRequest");
        }
        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
};

using CleanUpData = TCleanUpData<>;

#endif // __CLEAN_UP_ALL_HPP
