/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * Jan 22, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _CLEAN_AGENT_INVENTORY_HPP
#define _CLEAN_AGENT_INVENTORY_HPP

#include "chainOfResponsability.hpp"
#include "indexerConnector.hpp"
#include "inventorySync.hpp"
#include "loggerHelper.h"
#include "scanContext.hpp"
#include "socketDBWrapper.hpp"
#include "vulnerabilityScanner.hpp"
#include "wazuhDBQueryBuilder.hpp"

/**
 * @brief A class for handling data cleanup operations in the inventory database and publishing the changes to the
 * indexer.
 *
 * @tparam TIndexerConnector Indexer connector.
 * @tparam TScanContext Scan context.
 */
template<typename TIndexerConnector = IndexerConnector, typename TScanContext = ScanContext>
class TCleanAgentInventory final
    : public AbstractHandler<std::shared_ptr<TScanContext>>
    , public InventorySync
{
private:
    std::shared_ptr<AbstractHandler<std::shared_ptr<TScanContext>>> m_subOrchestration;

public:
    /**
     * @brief Class constructor.
     * @param inventoryDatabase Inventory database.
     */
    explicit TCleanAgentInventory(Utils::RocksDBWrapper& inventoryDatabase,
                                  std::shared_ptr<AbstractHandler<std::shared_ptr<TScanContext>>> subOrchestration)
        : m_subOrchestration(std::move(subOrchestration))
        , InventorySync(inventoryDatabase)
    {
    }

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * This method handles cleanup requests based on the operation type specified in the input data.
     * If the operation type is DeleteAll, it deletes all entries from the inventory database, logs the deletions and
     * publishes the changes to the indexer. If the operation type is SingleDeleteAndInsert, it performs specific
     * cleanup actions for entries related to a particular agent, logs those deletions and publishes the changes to the
     * indexer. If the operation type is not recognized, it throws a std::runtime_error.
     *
     * @param data Scan context.
     * @return std::shared_ptr<TScanContext> Abstract handler.
     */
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {
        std::string agentPackageKey;
        agentPackageKey.append(data->agentNodeName());
        agentPackageKey.append("_");
        agentPackageKey.append(data->agentId());
        agentPackageKey.append("_");

        logDebug2(WM_VULNSCAN_LOGTAG,
                  "Agent '%s' initiating database update: Removing all entries from inventory.",
                  std::string(data->agentId()).c_str());

        for (const auto& type : {AffectedComponentType::Os, AffectedComponentType::Package})
        {
            // Check if m_indexerConnector is available before processing the queries.
            for (const auto& dbQuery : m_inventoryDatabase.seek(agentPackageKey))
            {
                auto listCve = Utils::split(dbQuery.second.ToString(), ',');
                for (const auto& cve : listCve)
                {
                    std::string elementKey = dbQuery.first + "_" + cve; // Concatenate strings more efficiently.

                    auto context = std::make_shared<TScanContext>();
                    context->m_elements.emplace(elementKey, ScanContext::buildElement("DELETED", elementKey));
                    m_subOrchestration->handleRequest(std::move(context));
                    logDebug2(WM_VULNSCAN_LOGTAG, "Entry deletion: %s", elementKey.c_str());
                }
                m_inventoryDatabase.delete_(dbQuery.first);
            }
        }
        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
};

using CleanAgentInventory = TCleanAgentInventory<>;

#endif // _CLEAN_AGENT_INVENTORY_HPP
